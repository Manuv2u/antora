== Python

Python was designed and developed by **Guido Van Rossum**. +
The name comes from the Monty Python's Circus show on the BBC. +
Official website: http://www.python.org +

Python is a programming language used to write the coding part for application development.

== Django

Django is a web application development framework used to design and develop websites.

== Python Features

Python is a general-purpose, high-level, interpreted, dynamically typed, and case-sensitive programming language.

- *High level*: No need to manage memory and security-related aspects; these are handled by default.
- *Interpreted*: Python and JavaScript are interpreted languages, meaning they check and execute code line by line. They are also **dynamically typed**.

Example of dynamically typed:

ex:

    datatype varibalename=value
    a=10

- *Compiler-based*: Group of lines (the whole program code) are checked once and executed. These are **statically typed** languages. Examples include Java, C, C++, C#, and .NET.

Example of statically typed:

ex:

 datatype variablename = value;
 int x = 10;

why python?

huge standard libraries

NOTE: **immutable** : cannot change and **mutable** : can change



== Application area of python:

1. Standalone or desktop app -  console App(CUI) and Desktop GUI
2. web application(Django framework or flask)
3. Databased application
4. Gaming application
5. Data analysis (Datascience)
6. Statistical analysis
7. Testing, AI, ML, Devops, IOT, Business app, Network programming.

== Features of Python

. Simple and easy to learn
. Free and Open Source
. High Level
. Platform Independent (cross-platform)
. Portability ( one platform(windows) to other(linux) platform shift easy)
. Dynamically typed
. Procedure and object-oriented
. Extensible and Extensive library


== Different ways t write python script and execute:

1. Using Interactive mode
2. Using script mode(.py)
3. Using python IDLE
4. Using Pycharm editor


== Fundamental Concepts

===  1. Comments in python

- Single line comment

ex:
[source,python]
----
#this is single line comment
This is un-comment line
----

- Multi line comment

ex:
[source,python]
----
'''
this is multi line
comment example
'''
this is un-comment line
----

=== 2. Keywords and reserved words

keyword is library and this keyword are reserved form python, keywords cant be used as variable or personal use case.

ex:
[source,python]
----
import keyword
print(keyword.kwlist)
----

Output:

  ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']


=== 3. Indentation


4 spaces

=== 4. Identifiers

- Rule to define Identifier
. lowercase or Uppercase (ex:01)
. case sensitive
. allow digits(0-9) it should not Start with digits (ex:02)
. should not be two parts (ex:03)
. allow underscore(_)
. if an identifier starts with underscore then it is private
. we cant use any keyword or reserved word as identifier (ex:04)


ex:01
[source,python]
----
empid = 1234
   print(EMPID) # This is wrong it should be match with variable
   print(empid) # This is correct
----
NOTE: Always use lowercase for best pratices

ex:02
[source,python]
----
empid01 = 1234
01empid = 1234
   print(empid01) # This is correct
   print(01empid)  # This is wrong it should not start with digits
----

(ex:03)
[source,python]
----
emp id = 1234
empid = 1234
   print(emp id) # This is wrong it should not be two parts
   print(empid) # This is correct
----

(ex:04)
[source,python]
----
def = 1234
deff = 1234
   print(deff) # This is correct
   print(def) # This is wrong it should not keyword or reserved word as identifier
----


=== 5. Variables

. Variable is also consider as identifier
. variable is a named memory location
. while declaring the variable in python we need not specify any datatype because python is dynamically typed programming languages
. based on the value datatype will decide implicitly

(ex:01)
[source,python]
----
a = 1234
b = 10.9
c = "s"
   print(a)
   print(type(a)
   print(b)
   print(type(b)
   print(c)
   print(type(c)
----

==== 6. Multiple assignment
. Is the process of assigning the multiple value to multiple variables (ex:01)
. Is the process of assigning a single value to multiple variables (ex:02)


ex:01
[source,python]
----
a,b,c=10,20,30
    print(a,end=",")
    print(b,end=",")
    print(c) # here there is value for c attribute so we cant use end attribute for `c` value

----

ex:02
[source,python]
----
a = b = c = 10
   print(a,b,c) #or
   print(a)
   print(b)
   print(c)
   print(a,b,c,sep=":")
----


== DataTypes

Datatype is used to represent what type of values are going to store inside the variable.

=== Basic Datatype
// . None
// . Numeric
// - int
// - float
// - bool
// - complex
//
// . Sequence Datatype:
//
// -  String
// -  list
// - tuple
// - set
// - dict
// - range
// - bytes
// - bytearray
// - fronzenset

|===
| Basic Datatype | Description

| None
| Represents the absence of a value

| Numeric
| Represents numeric values

| int
| Integer numbers (e.g., -1, 0, 42)

| float (ex:02)
| Floating-point numbers (e.g., 3.14, -0.001)

| bool
| Boolean values (True or False)

| complex
| Complex numbers with a real and imaginary part

| Sequence Datatype
| Description

| String
| Ordered collection of characters (immutable)

| list
| Ordered collection of items (mutable)

| tuple
| Ordered collection of items (immutable)

| set
| Unordered collection of unique items

| dict
| Collection of key-value pairs

| range
| Sequence of numbers commonly used for looping

| bytes
| Sequence of integers representing raw binary data (immutable)

| bytearray
| Mutable sequence of integers representing binary data

| frozen set
| Immutable set of unique items

|===



ex:
[source,python]
----
a = None #in python
b = null #in other langauges
  print(a)
  print(b)
  print(type(a))
  print(type(b)) # you will get error and difference for python and other langauges
----


ex:
[source,python]
----
c = 10 # int
d = 5.5  # float
  print(c)
  print(d)
  print(type(c))
  print(type(d))

# how to convert int to float

e = float(c)
 print(e)
 print(type(e)) # converted `int to float`

 # how to convert   float to int

f = int(d)
 print(f)
 print(type(f)) # converted ` float to int`
----

ex:
[source,python]
----
name = " raju "
  print("your name is:",name)   #
name = input("Enter your Name:")  # run time inputs
  print("your name is:",name)
  print(type(name))
----


ex:
[source,python]
----
a = input("Enter A number:") # by default it will take as string so you need change to int
 print(type(a))
x = int(a)
 print(type(a))
b = input("Enter B number:") # by default it will take as string so you need change
 print(type(b))
y = int(b)
 print(type(y))
c = a+b
z = x+b
print(The result is:",c)
print(The result is:",z)
#output
#1020

----
NOTE: All inputs are taken as strings by default; explicit conversion is required for other data types. Conversion mechanism only for runtime execution

ex:
[source,python]
----
a = input(Enter Num1:")
b = input(Enter Num2:")
 print("result is:",a+b)

x = float(input(Enter Num1:"))
y = float(input(Enter Num2:"))
 print("result is:",x+y)
----

====  bool Datatype

only allowed value True as 1 and False as 0

ex: 01
[source,python]
----
a = 10
b = 20
c=a<b  #True
d=a>b  #False
 print(C)
 print(d)
 print(type(c))
 print(type(d))
 print(True+True)
 print(True+9)
----

==== complex
a+bj # j is imagernay numbers
ex:01
[source,python]
----
a=2
b=3
c=complex(a,b)
 print(c)
 print(type(c))
 print(c.real) # To print real and imagenary values
 print(c.imag)  # To print real and imagenary values 
----

ex:02
[source,python]
----
a=2+3j
b=5+2j
 print(a+b)
----


==== Sequence Datatype

**String**   :  String is a sequence of characters or group od character string can be represented with string and string can be created by using '' or "" or '''  ''' or """ """




print(dir(list))


help(str) #any str like list, tuple

=== Properties of Python Data Structures


[cols="1,1,1,1,1,1"]
|===
| DS      | create   | ordered | mutable    | immutable | duplicate

| str     | '' or "" | yes     | no         | yes       | yes
| list    | [ ]       | yes     | yes        | no        | yes
| tuple   | ( )       | yes     | no         | yes       | yes
| set     | { }       | no      | yes        | no        | no
| dict    | { }       | no      | keys: no  values: yes  | keys: yes values: no| keys: no values: yes
| range   | range()  | yes     | no        | yes       | no
|===



**list** :

. List is ordered collection of elements
. list can be created by using` [ ]`
. List will allow duplicate elements
. List contains different datatype elements
. List is mutable, once we create wa list that can change

ex:01
[source,python]
----
l = [10,20,30,"a",20,50]
  print(l)
  print(type(l))
----
**tuple** :

. tuple is ordered collection of elements
. tuple can be created by using `( )` but brackets are optional
. tuple will allow duplicate elements
. tuple contains different datatype elements
. tuple is immutable, once we create a tuple that cannot be change

NOTE: To create tuple with single element, after element we should give comma(,)

ex:01
[source,python]
----
t = (10,) #here for single element
  print(t)
  print(type(t))

----


ex:02
[source,python]
----
t = (10.0, 10, 20, "xyz", 'a', 23)
  print(t)
  print(type(t))
----


set :

. set is unordered collection of unique element.
. set can be created by using `{ }`.
. set contains different datatype elements.
. set is mutable once we create a set that can be modified.
. set will not allow duplicate values.
. To create an empty set then we use set() function.

NOTE:

ex:01
[source,python]
----
s = set()
q = {10, "sai", 'a', 20.3, 10,'a'} # no duplicate allowed, un-orderd(indexing is not fallowed).
  print(s)
  print(q)
  print(type(s))
  print(type(q))
----

**dect** :

. dect is unorderd collection of items.
. dict can be created by using { }.
. In dict each item can be a pair i.e key and value.
. keys are immutable, we cant change and values are mutable, we can change the values.
. In dict keys and value can be any type
. In dict keys must be unique and value need not be unique.

ex:01
[source,python]
----
d = {}
d1 = {1:"sai", name:"xyz", 3:"23.43"}
 print(type(d))
 print(type(d1))

----

**range** :

. range is ordered collection of values.
. range is used to generate sequence of values.
. range is immutable, once we create a range that cant change by default range will start from Zero
. To create range of values then we use range function.

ex:01
[source,python]
----
r = range(10)
a = range(2,11,2) #start stop step
  print(d)
  print(type(r))
  print(list(r)) #to print all sequence of value
  print(list(a)) # here we cna use tuple or any datatype
----
== Operators in python

Operater is symbole which is used to perform required operations. Python supports tha fallowing operators

1. Arithmetic
2. Relational
3. Assignment
4. Logical
5. Membership
6. Identity
7. Bitwise

=== Arithmentic:

==== Python Arithmetic Operators

[cols="1,1"]
|===
| Symbol  | Operation

| +       | addition
| -       | subtraction
| *       | multiplication
| **      | exponentiation(Power)
| /       | division
| //      | floor division
| %       | modulus
|===

ex:01
[source,python]
----
a = 10
b = 5
print(a+b) #addition
print(a-b) #subtraction
print(a*b) #multiplication
print(a**b) #exponentiation(Power)
print(a/b) #division
print(a//b) #floor division
print(a%b) #modulus
----

=== Relational:

=== Python Comparison Operators

[cols="1,1"]
|===
| Symbol  | Operation

| <       | less than
| >       | greater than
| < =      | less than or equal to
| >=      | greater than or equal to
| ==      | equal to
| !=      | not equal to
|===

ex:01
[source,python]
----
print(3<2)
print(3>2)
print(3>=2)
print(3<=2)
print(3==2)
print(3!=2)
----

=== Assignment

=== Python Assignment Operators

[cols="1,1"]
|===
| Symbol  | Operation

| =       | assign
| +=      | add and assign
| -=      | subtract and assign
| *=      | multiply and assign
| /=      | divide and assign
| //=     | floor divide and assign
| %=      | modulus and assign
|===


ex:01
[source,python]
----
a = 5
 print(a)

a+=2
 print(a)

b-=2
 print(b)

c*=2
  print(c)

d/=2
 print(d)

a//=2
  print(a)

a%=2
  print(a)
----


=== Logical

=== Python Logical Operators

[cols="1,1"]
|===
| Symbol | Operation

| and    | returns true if both conditions are true, else false
| or     | returns true if any one of the conditions is true or both conditions are true, else false
| not    | returns true if the condition is false, returns false if the condition is true
|===

ex:01
[source,python]
----
print(3<2 and 4<5)
print(3>2 and 4<5)

print(3<2 or 4<5)
print(3>2 or 4<5)
print(3<2 or 4>5)

print(not 4<5)
print(not 4>5)


----


=== Membership :
Membership operator are used to check whether than value is present in given sequence or not

=== Python Membership Operators

[cols="1,1"]
|===
| Symbol   | Operation

| in       | returns true if the value is present in the given sequence, else false
| not in   | returns true if the value is not present in the given sequence, else false
|===



ex:01
[source,python]
----
l = [10,20,30,40,50]
 print(10 in l)
 print(70 in l)

 print(100 not in l)
 print(10 not in l)

 print( 'r' in "Ranga")
 print( 'x' in "Ranga")

----

=== Idenetity :
Idenetity operators are used to check whether tha varibales or any python objects are having same identity or not.

=== Python Identity Operators

[cols="1,1"]
|===
| Symbol | Operation

| is     | returns true if the variables have the same identity, else false
| is not | returns true if the variables do not have the same identity, else false
|===


NOTE: id() : it is a builtin function in python, ir is used to find memory address of the object and it will return always unique interger.

ex:01
[source,python]
----
a = 2
b = 2
c = 4
d = 5
 print(a is b)
 print(a is not b)
 print(c is d)
 print( c is not d)
----


ex:01
[source,python]
----
a = "sai"
b = "sai"

 print(id(a)) # here memory address will be same a & b
 print(id(b))
----

=== Bitwise operators:
1. bitwise AND(&)
2. bitwise OR(|)
3. bitwise XOR(^)
4. bitwise NOR(~)
5. leftshift (<<)
6. rightshift (<<)

// ex:01
// [source,python]
// ----
//
// ----


=== Control flow statements:
1. Conditional Statements (**if, if else,nested if,elif** )
2. Iterative Statements (**for, while** )
3. Transfer statements (**break,continue,pass** )


==== Conditional Statements:
. **if** : `if` is used to test specific condition, if the condition is ture `if` block will execute
. **if else**
[source,python]
----
if condition:
statement
----


ex:01
[source,python]
----
n = int(input("Enter a number:"))

if n%2==0:
  print(n, "is Even")
else
  print(n, "is Odd")

i = 10
if i == 100:
   print("true")
else:
   print("false")

----

. **nested if** : Is used to check multiple conditions using `if` and `else if`

ex:01
[source,python]
----
i = int(input("Enter a number:" )) #i : 17

if i>20:
  print(i, "Is garter than 20")
else:
  if i>15:
    print(i, "Is garter than 15")
  else:
    print(i, "Is not garter than 15 and 20")


----

. **elif** : elif us the short form of `else if`

ex:01
[source,python]
----
i = int(input("Enter a number:"))
#here it will check all conditation if you given correct number
if i == 1:
     print("one")
elif i == 2:
     print("two")
elif i == 3:
     print("three")
elif i == 4:
     print("four")
else:
     print("Invalid Number")
----

==== Iterative Statements
. **for**:
for loop is used to iterate tha element of collection whar tha order they apper

[source,python]
----
for varibalename in sequence:
    statements
----
ex:01
[source,python]
----
#    0   1  2  3  4
l = [10,20,30,40,50,"xyz",20.15,'a',75]

print(l[0])
print(l[0])# here we cant print one by one

for i in l:
  print(i)
  print(type(i))
----


. **Nested for loop**:
A for loop which is having one more for loop within is called nested for loop.

[source,python]
----
for variablename in sequence:
    statements
     for variablename in sequence:
        statements
----

ex:01
[source,python]
----
#          0   1  2  3  4
numlist = [10,20,30,40,50]
charlist = ['a', 'b', 'c', 'd']

for n in numlist:
    print(n)
    for e in charlist:
          print(e)

----



NOTE: for every iteration of outer loop, inner loops should finish it's all iterations then only outer loop will start with next interation


. **while** : unknown iteration, like till the condition match

[source,python]
----
while condition:
    statements
----

ex:01
[source,python]
----
i = 1
  while i<=10:
         print(i,end=" ") # end function is to print all value in same name.
         i+=1 #i=i+1
----
==== Transfer statements

===== **break**: break is used to stop the iteration based on condition.

ex:01
[source,python]
----
for i in range(10):
   if i==4;
       break
   print(i,end=" ")
----

===== **continue**: continue is used to skip the current iteration and continue with the next iteration

ex:01
[source,python]
----
for i in range(10):
   if i==4 or i==6:
       continue
   print(i,end=" ") #it will skip that 4th number
----

ex:01
[source,python]
----
i = 1
while i<=10:
   if i==4:
        i+=1
       continue
   print(i,end=" ")
   i+=1
----
===== **pass**

ex:01
[source,python]
----
i = 1
while i<=10:
      pass

for i in range(10):
    pass

a = 10
if i==10:
   print("ture")
else:
   print("false")
----



=== String Datastructures

----
print(dir(str))
----

1. How to create string

ex:01
[source,python]
----
name = "cloudcatalist"
  print(name)
  print(type(name)) #here we can use '' or "" or '''
----

ex:01
[source,python]
----

s = ''' hi this is
cloudcatalyst doc'''
 print(s)# multiple line string
----

ex:01
[source,python]
----
m = "cloudcatalyst's"
  print(m)
----

=== String indexing and string slicing
backward direction is not possible in string

ex:01
[source,python]
----
# 0     1    2     3    4     5     6     7     8     9    10    11    12
# c     l    o     u    d     c     a     t     a     l    y     s      t
# -13  -12  -11   -10  -9    -8    -7    -6    -5    -4   -3    -2     -1


s = "cloudcatalyst"
  print(s[0:5]) # output : cloud
  print(s[-7:0])
  print(s[:]) #it will take 0 to 12
  print(s[0:9:1]) #start stop step
  print(s[::-1]) # we can revers
  print()
----


=== string concatenation and string multiplication

ex:01
[source,python]
----
s1 = "cloud"
s2 = "catalyst"
  print(s1+" "+s2) # string concatenation
  print((s1+" ")*3) # to print multiple times (multiplication)
----
=== string split and max split

ex:01
[source,python]
----
s = "c l o u d c a t a l y s t"
  print(s)
s1=s.split(" ")
  print(s1)
  print(type(s1))
a= "python is very easy"

s2=a.split(",",4)
  print(s2)
  print(type(s2))
----

=== string capatlis

ex:01
[source,python]
----

a="python is very easy"

  print(a)
  print(a.capitalize)# it will return start latter as capitalize
or
s1=a.capitalize
  print(s1)


 print(s.title)# here very word as return as capitalize
----


=== string count

ex:01
[source,python]
----
s = "python is vary easy and it is oop and it is interperted"

substring="is"
 print(s.count(substring))# to know repeted char
 print(s.count(" "))# to know the space

----


=== string replace

ex:01
[source,python]
----
s = "python is vary easy and it is oop and it is interperted"

  print(s.replace("python","java")) # it will replace python to java
  print(s.replace(" ","*"))# it will replace space(_) to *

----

=== string upper and lower case

ex:01
[source,python]
----
s = "python is vary easy and it is oop and it is interperted"
 print(s)
 print(s.upper())
 print(s.lower())
----
=== string swap case

ex:01
[source,python]
----
s = "pyThon is vAry easy aNd It is PPp AND it Is interPErted"
 print(s)
 print(s.swapcase())

----

=== string revers

ex:01
[source,python]
----
s = "python"
 print(s)
 print(::-1)
----

ex:01
[source,python]
----
l = ["sai","ram","raj"]
 print(" ".join(resersed(l)))
 print(":".join(resersed("ramu")))
----

=== string sort

Directly we can't apply sort to string, need to convert into sort and print

ex:01
[source,python]
----
s = "python is very easy"
s1=s,split(" ")
s1.sort()
 print(s1)
s1.sort(reverse=Ture)
 print(s1)

----

=== string - strip()
It returns a copy of string with both leading and trailing character removed

ex:01
[source,python]
----
s = "   ramu   "

 print(s)#there is a space in rigth and left side

 print(s.strip(" "))

OR

a = "AramuA"

 print(s)#there is a "A" in rigth and left side

 print(s.strip("A"))



----


=== string - lstrip()
It returns a copy of the string with leading characture removed.

ex:01
[source,python]
----
h = "AramuA"

 print(h)#there is a "A" in rigth and left side

 print(h.ltrip("A"))

----


=== string - rstrip()
It returns a copy of the string with trailing charature removed.

ex:01
[source,python]
----
r = "AramuA"

 print(r)#there is a "A" in rigth and left side

 print(r.rtrip("A"))

----

=== string - length
It is used to find length of string


ex:01
[source,python]
----
r = "python is vary easy and it is oop and it is interperted"

  print(s)
  print(len(s)) # it will consider spaces also

----

=== string - Find and index and rindex
It is used to find substring from given string, and return -1 if there is no substring


index: index is used to find substring from given string , and it return error

ex:01
[source,python]
----
op = "python is vary easy and it is oop and it is interperted"

 print(op.find("is")) # it will fine first one (occourent)
 print(op.find("x"))# it will return -1 becouse there is no x on "op"

 print(op.index("is"))
 print(op.index("x"))# it will return error

 print(op.rindex("is")) # it will return highest index of given string
 print(op.rindex("x"))# it will return error

----

=== string - max( ) and min ( )

Max( ): Highest alphabetical character in string
min ( ): List alphabetical character in string

ex:01
[source,python]
----
a = "alphabetICAl"

 print(max(a))
  print(min(a))

  print(ord("a"))# It will return accsi value of character
  print(ord("A"))
----


=== string - partition( )
Split the string at the first occurrence of the separator and returns a tuple format.

ex:01
[source,python]
----
p = "python is vary easy and it is oop and it is interperted"
 print(p.partition("is"))
 print(type(p.partition("is")))

----

=== string - startswith( )

Startswith return Ture if a string starts with the given suffix otherwise returns False.


ex:01
[source,python]
----
s = "python"
 print(s.startswith("P")) #it will give you false becouse it cap case
 print(s.startswith("p")) #it's correct

----


=== string - endswith( )
Endswith return Ture if a string ends with the given suffix otherwise returns False.


ex:01
[source,python]
----
s = "python"
 print(s.endswith("N")) #it will give you false becouse it cap case
 print(s.endswith("p")) #it's correct (here you can check with spcae also)

----
=== string - isdigit( )

Isdigit return "True" if all characters in the string are digits, otherwise, it returns "False".

ex:01
[source,python]
----
s = "1234563211"
  print(s.isdigit())# Ture


a = "123321a"
  print(a.isdigit())# False
----


=== string - isalpha( )

isalpha return "True" if all characters in the string are alphabets, otherwise, it returns "False".


ex:01
[source,python]
----
s = "abcdfegk"
  print(s.isalpha())# Ture

a = "abcd321a"
  print(a.isalpha())# False (even if its space also given False)
----


=== string - isalnum( )

isalnum return "True" if all characters in a given string are alphabets or numeric oe alphanumeric, otherwise, it returns "False".


ex:01
[source,python]
----
s = "abc"
  print(s.isalnum())# Ture

a = "321"
  print(a.isalnum())# Ture

i = "321#213"
  print(a.isalnum())# False

----

=== List Datastructures

----
print(dir(list))
----

Nested list : we can crate list in side other list


ex:01
[source,python]
----

#    0   1  2     3        4  5
#    0   1  2[  0     1  ] 4  5
l = [10,20,30,["sai","ram"],40,50]

 print(l(3))
 print(l(11))
----



=== list slicing and indexing..
ex:01
[source,python]
----
l = [10,20,30,40,50]
 print(l(3:4))
 print(l(11))
----

=== Changing and adding element to list
ex:01( update / replace)
[source,python]
----
#    0  1  2  3  4
l = [10,20,30,40,50]
  print(l)

l[1]=33 # here 1 is index and 33 is value
  print(l)

----
ex:01( insert  )
[source,python]
----
#    0  1  2  3  4
l = [10,20,30,40,50]
  print(l)

l.insert(1,33) # here we can insert value for 1 index
  print(l)

----

append and expend : append is for only one value at a time and expend is used add multiple value to the method. at the end of the list

ex:01 (append and expend)

[source,python]
----
l = [10,20,30,40,50]
  print(l)

l.append(80)
  print(l)

l.extend(["ram","raj",12,12.5])
  print(l)
----

=== Delete or remove element from list

ex:01

[source,python]
----
l = [10,20,30,40,50]
  print(l)

l.remove(20) # value method we can remove the value
  print(l)

l.pop(4) # to remove using index method
 print(l)

l.clear()
 print(l)# if you want to delete only item from the list, we can add value later


del l
 perint(l) # to delete l list
----


=== list sort
sort is the build in funcation, by default and its arrang items in ascending order


ex:01

[source,python]
----
l = [1,2,3,4,5,6,7,8,9]

  print(l)
l.sort(l)
l.sort(reverse=Ture)
----


=== list copy
shallow copy and deep copy two types

ex:01

[source,python]
----
l = [1,2,3,4,5,6,7,8,9]

l1 = l
 print(l1) #shallow copy (it depend on first copy (l))


l1 = l.copy
 print(l1) #shallow copy (it depend on first copy (l))


l1.append(14)

 print(l1)#deep copy (it will not effect on first copy (l1))

----
=== list count and index


 Count is used to find number of values(occurrence)

ex:01

[source,python]
----
l = [1,2,3,4,5,2,7,8,3,4,9,4,7,6,2,1,4,0,6,7]

  print(l.count(2))# count
  print(l.count(7))
  print(l.count(0))

  print(l.index(2))#index
  print(l.index(7))
  print(l.index(0))

----

=== Creating List from user input values

ex:01

[source,python]
----
l = []

item1 = int(input("Enter int value:"))
item2 = input("Enter string value:")
item3 = float(input("Enter float value:"))


l.append(item1)# here only one value is possible
l.append(item2)
l.append(item3)

print(l)

l1 = []

l1.extend(item1,item2,item3)# here we can add multiple values

print(l1)


----



=== Creating List using range function

ex:01

[source,python]
----
l = []

n = int(int("Enter length of the list:"))

for i in range(n):
  x = int(input("Enter the value:"))
  l.append(x)

print(l)

print(list(range(2,10,3)))

print(list(range(10)))
----


=== tuple Datastructures

=== len(), max(), min(), sum()


==== Converting a string into tuple

ex:01

[source,python]
----
s = "coludcatayist"
 print(s)
 print(type(s))

t=tuple(s)
 print(t)
 print(type(t))

----

==== Converting a list into tuple

ex:01

[source,python]
----
s = "10,20,30,40"
 print(s)
 print(type(s))

t=tuple(s)
 print(t)
 print(type(t))

----


==== Converting tuple into string



=== tuple packing and unpacking

ex:01

[source,python]
----
a = 10
b = 20
c = 30
d = 40

t = a,b,c,d

print(t) # packing
print(type(t))

t = (10,20,30)

a,b,c,d = t
 print("a=",a)
 print("b=",b)
 print("c=",c)
----


// take a string any thing
//
// ouput = print even position charters and odd position characters saparate.
//
//      0123456789
// s = "ptyojnkjsd"
//
// s = "pythonisgood"
//
// print("Even position characture:",s[0::2])
// print("Odd position characture:",s[0::1])
//
//
// or

=== Set Datastructures

1. Set not have any index becouse set is un-order

===  How to change set ( add and update)
ex:01

[source,python]
----
S = {} # its dic not set
s1 = set() # to create empty set
s2 = {10,20,30,10,45.5,"python"}
  print(s)# it will remove duplicate value
  print(type(s))
----

=== add and update in set
. add is used to update only one value
. update will allow multiple value to set

ex:01

[source,python]
----
s2 = {10,20,30,10,45.5,"python"}

 print(s2)

s2.add(98) # only one value to set use `add`

  print(s2)

s2.update(23,"cloud")

  print(s2) # multiple value to add use `update`
----

=== Remove elements form set (discard(), remove(), clear() and del() )


ex:01

[source,python]
----
s2 = {10,20,30,10,45.5,"python"}

 print(s2)

s2.discard(100)
  print(s2) # it will not give any error if that value is not persent in discard.


s2.remove(100)
  print(s2) #keyerror - if value is not there in set


s3 = {10,20,30,10,45.5,"python"}

 print(s3)

s3.clear() # will clear all value in set(total set as empty)
  print(s3)

----

=== Set Operation { union(|), intersection(&), difference(-), symmetric difference(^) }
. union


ex:01

[source,python]
----
a = {1,2,3,4,5,6,7}
b = {8,9,7,6,5,4,1}
 print(a|b) # union
print(a.union(b))


c = {1,2,3,4,5,6,7}
d = {8,9,7,6,5,4,1}
 print(c&d) # intersection
 print(c.intersection(d))

e = {1,2,3,4,5,6,7}
f = {8,9,7,6,5,4,1}
 print(e-f) # difference
 print(e.difference(f))


g = {1,2,3,4,5,6,7}
h = {8,9,7,6,5,4,1}
 print(g^h) # symmetric_difference
 print(g.symmetric_difference(h))
----


=== membership test

ex:01

[source,python]
----
a = {1,2,3,4,5,6,7}

 print(100 in a) # membership test ( to check number is there or not )

----


=== len( ), max( ), min( ) and sum( )

ex:01

[source,python]
----
# coming soon
----

=== Dictionary Datastructures

1. what is dictionary ?
2. Creating dictionary
3. access



ex:01

[source,python]
----

d = {}

  print(d)
  print(type(d))

d1 = {1:"python", 2.1:"is", id:"easy",(1,2,3):"to",4:"learn"}

   print(d1(1))
   print(d1.get(1))
----

=== change or update

ex:01

[source,python]
----

d1 = {1:"python", 2.1:"is", id:"easy",(1,2,3):"to",4:"learn"}
d1["id"]="slno"
   print(d1) # if there is no key and value then that it will update new key value


#delete

d = {1:"python", 2.1:"is", id:"easy",(1,2,3):"to",4:"learn"}

  print(d)

del d["id"]
  print(d) # to delete perticulr key value


del d
  print(d) # to delete hole dic

# copy

d = {"id":"1235", "name":"python"}
d1=d.copy()

d1=["id"]=4355
 print(d1)


# items, key, value

d = {"id":"1235", "name":"python", "age":15}

  print(d)
  print(d.items())
  print(d.values())
  print(d.keys())


# membership test

d = {"id":"1235", "name":"python", "age":15}

 print(d)

 print("id" in d) # here we can check key only not for value it not possiable

# len

d = {"id":"1235", "name":"python", "age":15}

 print(d)
 print(len(d))

# pop


d = {"id":"1235", "name":"python", "age":15}

 print(d)

d1=d.pop("name") # delete using key

 print(d1)

#popiteam


d = {"id":"1235", "name":"python", "age":15}

 print(d)

d1=d.popitem()# last key:value will be deleted

 print(d1)
----


=== bytes
bytes is used to represent byte number just like an array the only allowed value for bytes is 0 to 256, and bytes is immuyable(we cant change).


=== bytearray

bytearray is used to represent byte number just like an array that only allowed values for bytearray is 0 to 256 and bytearray is mutable (we can change)


=== frozenset
 frozenset is mutable(we cant change)



== Function in python:

A function in Python is a reusable block of code that performs a specific task. It is defined using the def keyword followed by the function name and parentheses () which may include parameters. Functions help in organizing code, making it more readable, and avoiding repetition.


=== two type functions

1. perdefined function

 ex: print(),input(),type(),id()

2. userdefined function

----

import keyword
print(keyword.kwlist)
----

ex: syntax for function
[source,python]
----
def function_name(parameters): #parameters are input values
     '''docstring''' # distribution for funcation
     statements  # main task or any logic
     return statement # return is keyword that gives some output
----

ex:01
[source,python]
----
def f1():
  print("hello")

f1()
--
def f2():
    for i in range(100):
        print("hello")
--
def f5():
  pass # we can skip that function
--
def f6(name):
    print("hello:",name)

f6("coludcatayist")
---
def f7(n):
    print("square of",n, "is",n*n)
f7(5)
---
def add(a,b):
    print("sum is:",a+b)

add(5,20)
add(11.2,65.78)
---
a = int(input("Enter num1:")) # giving value at run time
b = int(input("Enter num2:")) # giving value at run time
def add(a,b):
    print("sum is:",a+b)
--or--
a = int(input("Enter num1:")) # giving value at run time
b = int(input("Enter num2:")) # giving value at run time

add(a=int(input("Enter num1:")),b=int(input("Enter num2:")))
---
def iseven(x):
     if x%2==0
        print(x, "is Eeven")
     else:
        print(x, "is odd")
iseven(3)
iseven(4)
----
ex:
[source,python]
----
def add(a,b):
    #print("sum is:", a+b)
    return a+b #


print("sum is:",add(20,60))
r = add(20,60)

def sub(r,c)
    print("sub is:",r-c)


sub(r,6)


----

==== single function can retrun multiple values


ex:
[source,python]
----
def sum_sub(a,b):
    sum=a+b
    sub=a-b
    mul=a*b
    return sum,sub,mul


x,y,z= sum_sub(10,20)

print("Sum is:",x)
print("Sub is:",y)#this is not good pratices
print("mul is:",z)# here we can do only sum or mul or sub (like addition only)
----

ex:
[source,python]
----
def sum(a,b)
     return a+b

def sub(a,b)
    return a-b


def mul(a,b)
    return a*b

x=sum(10,20)
y=sub(30,20)
z=mul(20,10)

print("Sum is:",x)
print("Sub is:",y)
print("mul is:",z)

----
=== Types of variables in funcation (local and global variables)

1. Local variables:

The variables which are declare inside the function and that variables are only available to thet  function is called local variables.

local variables can't access outside the funcation


ex:
[source,python]
----
def f1():
    a=10
    print(a)

def f2():
    b=20
    print(b)
    print(a)# here we cant use `a` that variable is not define in this function

f1()
f2()

----


==== 2. Global variable:

The variables which are declare outside the function and that variables are only available to all function in the program is called global variables.


==== Global keyword

Global key is used to make global variable available to a particular function for required modification.
----
import keyword
print(keyword.kwlist)# to print all keyword in python
----
ex:
[source,python]
----
a=10#this are global variables
b=20# it available to access not for modification.

def f1():
    print(a)

def f2():
    print(b)

f1()
f2()

----


ex:
[source,python]
----
a=10

def f1():
    global a
    a=99
    print(a)

def f2():
    print(a)


f1()
f2()
----

ex:
[source,python]
----
a=10

def f1():
    a=99 # here local and globale variable both are same then first perferance is local variable
    print(a)
    print(globals()['a']) # here am calling global variable

def f2():
    print(a)


f1()
f2()
----

=== Different type of arguments(paraments)

==== There are four types of arguments

- positional arguments
- keyword arguments
- default arguments
- variable length arguments


==== 1. positional arguments

The argument which are passed to a function in correct positional order is called positional arguments

if we change order or position then result may change, if we increase or decrease the no of arguments then we get error.


ex:
[source,python]
----
def sub(a,b):
    print(a-b)

sub(10,20) # here a,b are formal arguments and 10,20 are actual arguments
sub(20,10) # ex: sub(10,20,30) and sub(10) here check the definition

----


==== 2. keyword arguments

The arguments which are passed to a function with keyword or parameter name is called keyword arguments.

while working with keyword arguments the order or position is not important but keyword are important.

ex:
[source,python]
----

def f1(name,msg):
    print("Hello:",name,msg)

#keyword args
f1(name="chiru",msg="Good Morning")
f1(msg="Good Morning",name="chiru")# here if i change order result will be same


#positional args
f1("chiru","Good Morning")
f1("Good Morning","chiru")# here there based on order you will get

#one  positional and one keyword args
#make sure that first we have to mention positional args then after keyword args

f1("chiru",msg="Good Morning") #correct
f1(name="chiru","Good Morning") #wrong (error will occure)
----

==== 3. default arguments

if you don't set any args,

function with default value will take that value

ex:
[source,python]
----
def f1(course="python"): # here i define default value as python
    print("course is:",course)

f1("c")

f1("java")

f1() # here am not given any args so it will take default value to the parameter

# one default one non default argument, make sure that first non default argument and then after default argument
def f2(course="python",name): # here i define default value as python
    print(name,"course is:",course)

f2("java","sumanth") #here we need to pass non default args first
f2("chiru","c") # correct
f2("chiru") # here i define default value as python
----

==== 4. variable length arguments

some time we can call a function with multiple values including zero(0) value
ex:
[source,python]
----
def f1(*a): # here `*` is most important for variable args
    print(a)

f1()
f1(10)
f1(10,20)
f1(10,20,30)
f1(10,20,30,40,50)


----

ex:
[source,python]
----
def add(*n):
    s=0
    for i in n:
        s=s+i
    print("Sum is:",s)

add()
add(10)
add(10,20)
add(10,20.2,0,995,65.45)
----


IMPORTANT: Interview Question - ( What is `*args` and **kwargs ?)
----
*args allows us to pass no zero(0) value to the function including zero +
*args will store the value in tuple formate +
**kwargs allow us to pass no of keyword arguments to the funcation +
**kwargs will store the values in dict formate+
----

ex:
[source,python]
----
def f1(**kwargs):
    for k,v in kwarges,items():
        print(_k_,"=",v)

f1(a=20,b=20,c=30)
f1(eid=125,ename="chiru",eaddress="bang")


----

==== Positional only arguments and Keyword only arguments
ex:
[source,python]
----
def add(a,b): # here it will accepts both
    print(a+b)

add(10,20)# positional arguments
add(a=10,b=20)# keyword arguments

# how to pass only positional argumenets

def sum(x,y,/): # here we need to use `/`
    print(x+y)

sum(10,20)# it will accept only positional arguments
sum(x=10,y=20)# error

# how to pass only keyword argumenets

def sub(*,s,r): # here we need usr `*`
    print(s-r)

sub(10,20)#  error
sub(s=10,r=20)# it will accept only keyword arguments

# Note: we cant use both like

def sum(*,a,b,/): # wrong we can use both args
    print(a+b)

----

==== nested function
A function which is having one or more function within it is called nested function

ex:
[source,python]
----
def f1():
    print("hello")

    def f2():
        print("welcome to python")

        def f3():
            print(learing..)

         f3() # its depends on f2 function

    f2()# its depends on f1 function

f1() #here with out f1 function f2 and f3 function will not work
----

==== recursion function

factorial(n)=n*factorial(n-1)
factorial(3)=3*factorial(2-1)
             3*2*factorial(1)
             3*factorial(0)


ex:
[source,python]
----
def factorial(n):
    if n==0:
       result=1
    else:
       result=n*factorial(n-1)
    return result
print("Factorial of ,n is",factorial(3))

or

import math

print(math.factorial(3))
print(math.sqrt(4))
print(math.pow(3,2))
print(math.ceil(34.2))
print(math.floor(43.6))

or
# here without using alias name here we need call module in different style

from math import *

print(factorial(3))
print(sqrt(4))
print(pow(3,2))
print(ceil(34.2))
print(floor(43.6))
----

==== Anonymous or lambda function

When we create(some times) a function without any name such kind of nameless function are called anonymous or lambda function.


. using lambda we can write concise code(short hand way if writing code).
. using lambda we can reduce length of code.
. using lambda we can improve the readability of program.
. using lambda we can almost singlr line expression.
. lambdas are for instant usage.

----
#To get all keywords in python
import keyword
print(keyword.kwlist)
----

----
#sytax of lambda function
lambda argumenetslist:experssion
----

ex:
[source,python]
----
lambda n : n*n # squar of given number

lambda a,b : a+b #To find sum of number

s =lambda n: n*n

  print(s(3))

# To find sum of two numbers using lambda function

a =lambda x,y: x+y

  print(a(3,5))


# To find biggest number in lambda function

q = lambda a,b:a if a>b else b

print(q(5,6))


s = lambda a,b,c:a if a>b and a>c else b if b>c else c

print(a(9,6,1))

# To find even or odd number using lambda function

a = lambda n:"is even" if n%==0 elsw "is odd"

print(a(2))
print(a(7))
----

==== Use case of lambda (advantage)

. sometimes we should pass a function as an argument to other function in this situation lambda is the best choice.

. In Python programming some function will expect other finction as an argument then we use lambda

. filter( ),map(),reduce( )

- filter( ) :
 filter is used to filter the value from given sequence based on the condition

----
syntax : filter(function,sequence)
----

here first parameter is a function for conditional check, here second parameter is a sequence and it can be  a list,tuple,set

ex:
[source,python]
----
# without lambda

def iseven(x):
    if x%==0:
       return True
    else:
       return False

iseven(10)

l= [2,3,4,5,6,7,8,9,10]

#filter(function,sequence)
l1=list(filter(iseven,l))

print(l1)


#with lambda

l= [2,3,4,5,6,7,8,9,10]

#filter(function,sequence)
l1=list(filter(lambda x:x%2==0,l))

print(l1)

----

- map( )

For every element present in the sequence, apply some condition and return the new sequence of element then we use map() function.


----
syntax : map(function,sequence)
----
ex:
[source,python]
----
# without lambda
def dbl(x):
     return 2*x # use can you any alg like 2**x

l= [2,3,4,5,6,7,8,9,10]

#map(function,sequence)
l1=list(map(dbl,l))

print(l1)

#with lambda

l= [2,3,4,5,6,7,8,9,10]

#map(function,sequence)
l1=list(map(lambda x:x*x,l))

print(l1)

----

- reduce( ) #it not available as default keyword, so we need to use labiary

it is used to reduce the values of sequence and return the result as one value.

----
syntax : reduce(function,sequence)
----


ex:
[source,python]
----

# without lambda

from functools import * # to call all labiary is not good practices only use what every function you need
# from functools import reduce
def f1(x,y):
    return x+y # here you can use any

l=[1,2,3,4,5,6,7,8,9,10]

result= reduce(f1, l)

print(result)

# with lambda

from functools import reduce

l=[1,2,3,4,5,6,7,8,9,10]

result= reduce(lambda x,y:x+y, l)

print(l)

----

== modules in python

. Group of variables, functions and classes are store into a file which is nothing but module.
. In python every .py file acts as module and module is for re-usability of enter the program code


ex:

[source,python]
----
#sample.py(file1)

a =100

def add(x,y):
    print("sum is:",x+y)

def sub(x,y):
    print("sub is :",x-y)

#test.py(file2)

import sample #here we need to mention file name

print(sample.a) # how to call varibale form one file to other

# how to call function form sample.py file

sample.add(20,10)
sample.sum(50,60)
----

=== module aliasing
 just giving other name to a module is called module aliasing


ex:
[source,python]
----
import sample as s #always we need to use alias name only, we can't use main name


# without using module name how to use module for that we need to use from

from sample import a,add # here iam accessing a and add functions form sample file



----

=== member aliasing
 just giving other name to a member is called member aliasing

ex:
[source,python]
----
from sample import a as b,add as sum,sub

print(b)
sum(20,10)
sub(3,1)
----

=== How to import multiple modules

. user define
. build in module
.


ex:
[source,python]
----
#sample.py (file1)

a = 200

def mul(x,y):
    print("mul is:",x*y)

#test.py (file2)


a = 100

def add(x,y):
    print("sum is:",x+y)

def sub(x,y):
    print("sub is :",x-y)

#test2.py (file3)


import sample
import test

#from sample import *
#from test import * # here with using module name we can use

print(sample.a)
sample.mul(10,5)

print(test.a)
test.add(10,20)
test.sub(20,30)

----

=== How get all information about any module

ex:
[source,python]
----
import sample
help(sample)

import functools
help(functools)

import os
help(os)
----

=== Different ways to call module


ex:
[source,python]
----
import module1
import module1 as m1
import module1,module2
import module as m1,module2 as m2

form module1 import *
from module1 import member1
from module1 import member1 as m1
from module1 import member1,member2
from module1 import member1 as m1,module2 as m2

----
=== Special varibale:

----
__name__
----
special variable name is used to check wreath the program execute as is individual program, or it's execeuted by other program

If the program executed as an individual program then the value of special variable is
----
__name__
----

If the program executed from other program then the value of special variable is the module name where it is defined.

ex:
[source,python]
----
test.py(file1)

def f1()
    if __name__=='__main__':
        print("Executed as an individual program")
    else:
        print("Executed from some other program")

f1()
print(__name__) # To print name of module
#output
Executed as an individual program
__main__
----

ex:
[source,python]
----
import test1

test.f1()
print(__name__) # To print name of that module
#output
Executed from some other program
test1

----

=== built in modules in Python

ex:
[source,python]
----
import math
#from math import *
print(math.sqrt(4))
print(math.factorial(3))
print(math.ceil(34.2))
print(math.floor(34.4))
--------------------------
import datetime #
#from datetime import *
x = datetime.datetime.now()
print(x)
print(x.date())# only for date
print(x.time())# only for time
print(x.year())
print(x.hour())
print(x.minute())
print(x.seconds())
print(x.microsecond())

x=date(2024,7,29)#(year,month,day)
  print(x)

y=datetime(2024,7,29,2,35,45)#(year,month,day,hour,minute,second)
  print(x)
------------------
# To print in string formate
from datetime import *
x=datetime.now()
  print(x.strftimr("%A")) #Weekday full version
  print(x.strftimr("%a")) #weekday short version
  print(x.strftimr("%B")) #month full version
  print(x.strftimr("%b")) #month short version
  print(x.strftimr("%Y")) #year full version
  print(x.strftimr("%y")) #year short version
----------------------------------

from calendar import *
#help(calendar)
y = 2002
m = 6

print(month(y,m))
print(month(2002,6))
print(calendar(2002,2,1,6,))#y,w,l,c
#y=year
#w=width of the characters
#l=lines per week
#c=column separation
----

=== Working with random module

1. random() : It will generate random flot values by default between 0 and 1 (not-include(0 and 1))
2. randint() : It will generate random int values  between two given numbers (include(two given number))
3. uniform() : It will generate random flot values by default between two given number (include - two given number)
4. randrange() : Start,stop,step
5. choice() : it will not generate any random value, it will generate random object


ex:
[source,python]
----
#random function
from random import *

for i in range(10):
     print(random())


#randint function

for i in range(25): #output of range value
     print(randint(0000,9999))


#uniform function
for i in range(15): #output of range value
     print(randint(3,18))


#randrange function
for i in range(10): #output of range value
     print(randrange(2,20,2))

#choice function
l = ["ranga","chiru","sumanth","vinay"]
print(choice(l))

----

=== array and numpy  modules

==== array

array is user define similar data type collection (homogenious element)
only we can create single dimension array

. **Single dimension array** : An array which contains only one row or one column
. **Two dimension array** : An array which contains more than one row or one column

----
[10,20,20,30,40]
["ranga","chiru","sumanth","vinay"]
[11.2,56.4,45.3,87.01,53.15]
#list[]  -> heterogenious elements
----


#need to install the package

it used to create multiple array

ex:
[source,python]
----
import array
#from array import *
#from array import
#type code varibale

A = arry.arry(['i',10,20,30,40,50,60,70]) # here we need to give type code variable
B = arry.arry(['f',10,20,30,40,50,60,70])#float
C = arry.arry(['D',10,20,30,40,50,60,70])#float
D = arry.arry(['I',10,20,30,40,50,60,70])#interger
E = arry.arry(['i',10,20,30,40,50,60,70])#unicode character

print(type(A))
print(A.typecode)
print(A) # same as all B,C,D,E try your self
print(a[1])#how to access or printe array
A.remove(2)# how to remove values
print(A)
A.inster(1,33)#insert ( index,value)
A.reverse()# how to reverse


for i in A:
    print(i)

for i in range(4):
     print(A[i])

for i in len(A):
     print(A[i])

----

==== How to create array in run time

ex:
[source,python]
----
from array import *

A = array('i',[])

n = int(input("Enter length of the array))

for i in range(n):
    x=int(input("Enter the value:"))
    A.append(x)
print(A)

----

==== numpy :
1. array( )
2. linspace( )
3. logspace( )
4. arange( )
5. zeros( )
6. ones( )


ex:
[source,python]
----
#array
import numpy
#import numpy as np
#from numpy import *

X = numpy.array ([10,20,30,40.8])
A = numpy.array ([10,20,30,40.8]) # here we give any float value, it automatically converted into float
B = numpy.arry([10,20,30,40.8],int)

print(X)
print(type(X))
print(A)
print(type(A))
print(B)
print(type(B)) #int32
Print(B.dtype) #4
Print(B.size) #1
Print(B.shape) #(4,)


#linspace (start,stop,no of parts )# matlab function

C = numpy.linspace(2,20,7)#(start,stop,no of parts )
print(C)

#logspace (start,stop,no of parts )# matlab function

D = numpy.logspace(2,20,7)#(start,stop,no of parts )
print(D) # [1.00000000e+02, 3.1617766e+11, 3.16227766+e15, 1.000000000+e20]

#arange (start,stop,no of parts )# matlab function

E = numpy.arange(2,20,3)#(start,stop,no of parts )
print(E)# [2 5 8 11 14 17]

#zeros (start,stop,no of parts )# matlab function

F = numpy.zeros(10, dtype=int)
print(F)# [0 0 0 0 0 0 0 0 0 0]

#ones (start,stop,no of parts )# matlab function
G = numpy.ones(10, dtype=int)
print(G)# [1 1 1 1 1 1 1 1 1 1]
----

ex:
[source,python]
----
# mutli dimenation array

import numpy as np

A = np.array([[10,20,30,40]),
            ([15,25,35,45]),
            ([43,87,93,21]])

print(A)
print(A.ndin)
print(A.size)
print(A.shap)
print(A[2][0])


# how to find max element and min element
print("Max elemenr is:" A.max())
print("Min elemenr is:" A.min())

print("Row wise Max elemenr is:" A.max(axis=1))# here to access row wise axis = 1
print("Row wise min elemenr is:" A.min(axis=1))

print("Columm wise Max elemenr is:" A.max(axis=0))# here to access cloumm wise axis = 0
print("Columm wise min elemenr is:" A.min(axis=0))

print("Sum of all element:"A.sum())

#flatted = it's converted all row and colum into single row( single dimention)
print(A.ndim)
P = A.flatted()
print(P)
print(p.ndim)
----


== Advance Python


=== Object Oriented programming ( OOP'S)

==== Advantage or Benefits

. Security
. Re-usability
. Application Enhancement




1.class :
class is a collection if variables and method

2.object :
Object is an instance of class or it is used to represent a class +

==== Features of OOPs

. Encapsulation
. Abstraction
. Polymorphism
. Inheritance

1.Encapsulation : Encapsulation is the process of providing restriction to access variables and method

- why we need Encapsulation

. To prevent the data from modification
. We can achieve the encapsulation by using private variables and methods


2.Abstraction : Abstraction is the process of hiding the implementation but providing the service



3.Polymorphism : Poly means many and morph means behavior

. Static or Compiletime (overloading)
. dynamic or runtime (overriding)

4.Inheritance :  Inheritance is the process of creating new class from existing class.

 - Existing class are parent class or base class or super class
 - New class are child class or derived class or subclass

==== Types of Inheritance
. Single
. Multiple
. Multilevel
. Hybrid
. Hierarchical

==== Syntax to Create class

ex:
[source,python]
----
Class classname:
#Class stuent:

----
==== Syntax to Create object

ex:
[source,python]
----
objectreferencevariablename = Classname()
#s = Student()

----

==== How to Prepare class

ex:
[source,python]
----
Class Student:
     ''' This is a student class to display student details '''

// help(student)
// s = Student()
// print(s.__doc__) #this called as magic method

    def __init__(self):
        self.sid=2345
        self.sname="ram"
        self.saddress="bang"

    def display(self):
        print("Student id is:", self.sid)
        print("Student name is:", self.sname)
        print("Student Address is:", self.saddress)


s = student() # s is object, student is class
s.display()

----

==== What is constructor ?
. Constructor is a special method of class.
. Constructor name should be "_ _ init _ _" (self) # In other lang name of the constructor should be  same as class name
. Self is the first parameter of constructor
. Constructor is used to declare and initialize the values to the variables
. Constructor will execute automatically when create objcet to the class.
. We can create any no of objects to the class, for every object constructor will execute once.

#In other languages name of the constructor should be same as class name. +
#In python always Constructor name is "_ _ init _ _"


==== What is Method ?
. Method is a reusable piece of code which can be called again and again when it is required.
. Method mame can be of any name
. self is the first parameter of the method
. In side method we can write any business logic code
. Method will execute only when we call that
. For every object we can call a method with any number of times


ex:
[source,python]
----

#constructor and Method
#constructor
class Studnet:
     def __init__(self,sid,sname,saddress): #(self,x,y,z) or
         self.sid=sid #self.sid=x
         self.sname=sname #self.sname=y
         self.saddress=sadress #self.saddress=z
#Method
     def display(self):
         print("Student id is :",self.sid)
         print("Student name is :",self.sname)
         print("Student Address is :", self.saddress)


s1=Studnet(101,"ranga","D-Rampura")# (inside class)
s2=Studnet(102,"Chiru","KB-cross")
s1.display()#s1 is object reference (outside class)
s2.display()

----


ex:
[source,python]
----
#if you dont have any method how to print (using dict)
#constructor
class Studnet:
     def __init__(self,x,y,z): #(self,x,y,z)(self,sid,sname,saddress) or
         self.sid=x
         self.sname=y
         self.saddress=z

s1=Studnet(101,"ranga","D-Rampura")
s2=Studnet(102,"Chiru","KB-cross")

#if you dont have any method how to print (using dict)

print(s1.__dict__)
print(s2.__dict__)

----

ex:
[source,python]
----
# if we dont have any constructor
class Studnet:
     def getdata(self):
         self.sid=int(input("Enter sid:"))
         self.sname=input("Enter sname:")
         self.saddress=input("Enter saddress:")
#Method
     def display(self):
         print("Student id is :",self.sid)
         print("Student name is :",self.sname)
         print("Student Address is :", self.saddress)

s1=Studnet()
s2=Studnet()
s1.getdata()
s2.getdata()
s1.display()
s2.display()
----


ex:
[source,python]
----
class Studnet:
     def getdata(self):
         self.sid=int(input("Enter sid:"))
         self.sname=input("Enter sname:")
         self.saddress=input("Enter saddress:")
#Method
     def display(self):
        # print(self.sid ,"\n",self.sname,"\n",self.saddress) # "\n" is next line"
        # print("{}'s id is{}".format(self.sname,self. sid, self.saddress))#string
        print("{0}'s id is{1} and address is {2}".format(self.sname,self. sid, self.saddress))#based on index we can get result
s1=Studnet()
s2=Studnet()
s1.getdata()
s2.getdata()
s1.display()
s2.display()
----
=== Type of variables are allowed in python class

. Instance variable(object level)
. Static variables (class level)
. local variables (method level)

==== Instance variables (object level)
- If the value of variable is varied(different) from object to object then such type of variables called instance variables.
- Where we can declare instance variables
. inside the constructor by using self
. inside the instance method by using self
. outside the class by using object reference


ex:
[source,python]
----
class Test:
    def __init__(self): # "__init__ (constructor))"
       self.a =10

    def m1(self):
        self.b=20

t = Test()
t.m1()
t.c=30

print(t.__dict__)


#output

{'a': 10, 'b': 20, 'c': 30}

----

==== How to access instance variables

- We can access instance variables with the class by using self
- we can access instance variables outside the class by using object reference


ex:
[source,python]
----

class Test:
    def __init__(self):
        self.a=10
        self.b=20
    def m1(self):
        print(self.a)# inside of the class we can access the instance variables
        print(self.b)# self will work only inside class

t = Test()
print(t.a)# outside of the class we can access the instance variables
print(t.b)

----



==== How to delete instance variables

- We can delete instance variables within the class as follows
----
 del self.variablesname
----

- We can delete instance variables outside of the class as follows
----
 del objectreference.variablesname
----

NOTE: We can create any number of object to the class, for every object a separate copy of instance variables will be created if we change or delete one copy of instance variable then other copy od instance variables will not affect.

ex:
[source,python]
----
class Test:
    def __init__(self):
        self.a=10
        self.b=20
        self.c=30

    def m1(self):
        del self.a

t = Test()
print(t.__dict__)

#output
{'a': 10, 'b': 20, 'c': 30}

---
# with in the class and # ( outside class) object reference
class Test:
    def __init__(self):
        self.a=10
        self.b=20
        self.c=30

    def m1(self):
        del self.a

t1 = Test()
t2 = Test()
print(t1.__dict__)
print(t2.__dict__)
t1.m1()# with in the class
del t2.b # ( outside class) object reference
print(t1.__dict__)
print(t2.__dict__)



#output

{'a': 10, 'b': 20, 'c': 30}
{'a': 10, 'b': 20, 'c': 30}
{'b': 20, 'c': 30}
{'a': 10, 'c': 30}

----

==== Static variables (class level)

- If the value of variable is varied(different) from object to object then such type of variable we can declare directly inside the class but outside the methods are called static or class level variables.
- The variables which are declare within the class but outside the methods is called static variables
- For all object there is only one copy of static variables will be created.
- We can access static variables either by using class name or object reference



ex:
[source,python]
----
class Test:
    a = 10 # static or class level variable

    def __init__(self):
        self.b=20 #instance Variable

t1 = Test()
t2 = Test()

print(t1.a,t1.b)
print(t2.a,t2.b)

Test.a=98
t1.b=55

print(t1.a,t1.b)
print(t2.a,t2.b)

----

=== Where we can access static variable

- In side the constructor by using `self` or `classname`
- Inside the instance method by using `self` or `classname`
- Inside the class method by using `cls` or `classname`
- Inside the static method by using class name only
- Outside the class by using `object reference` or `classname`

ex:
[source,python]
----
class Test:
    a = 100 #static variable

    def __init__(self):
        print("Inside the constructor")
        print(self.a) #using Inside the construtor
        print(Test.a) # using

    def m1(self):
        print("Inside the constructor")
        print(self.a) #using Inside the construtor
        print(Test.a)

    @classmethod
    def m2(cls):
        print("Inside the class mehtod")
        print(cls.a)
        print(Test.a)

    @staticmethod
    def m3():
        print("Inside the static method")
        print(Test.a)

t = Test()
t.m1()
t.m2()
t.m3()
print("Outside of the class")
print(t.a)
print(Test.a)

----

==== how to delete static variables

- We can delete static variable anywhere as follows

----
del classname.variablename

----

ex:
[source,python]
----
class Test:
    a = 100 #static variable

    def __init__(self):
        print("Inside the constructor")
        print(self.a) #using Inside the construtor
        print(Test.a) # using

    def m1(self):
        print("Inside the constructor")
        print(self.a) #using Inside the construtor
        print(Test.a)
    #   del Test.a

    @classmethod
    def m2(cls):
        print("Inside the class mehtod")
        print(cls.a)
        print(Test.a)
        del Test.a

    @staticmethod
    def m3():
        print("Inside the static method")
        print(Test.a)

t = Test()
t.m1()
t.m2()
t.m3()
print("Outside of the class")
print(t.a)
print(Test.a)

----



==== local variable or method level variables

. The variables which are declared inside the particular methods and that variables are available to only that method is called local or method variables
. Local variables are also called as temporary variables because these variables will create when we execute the methods once method execution completes the these variables will be destroy.

ex:
[source,python]
----
class Test:
    def m1(self):
        a=10
        print(a)

    def m2(self):
        b=20
        print(b)
        # print(a) # here we cant access a variable

t=Test()
t.m1()
t.m2()

----

=== Types of methods are all allowed in python class

1. Instance methods
2. class methods
3. static methods

==== Instance methods
- In side method implementation when we use instance variables then such type of methods are called as instance method.
- While declaring instance methods we should pass self
- Self is the first parameter of  within instance methods
- we can access instance methods with in the class by using self
- we can access instance methods within the class by using self
- we can access instance methods outside the clss using object reference

ex:
[source,python]
----
class Student:
    def __init__(self,m1,m2,m3):
        self.m1=m1
        self.m2=m2
        self.m3=m3
        self.average()#inside the class

    def average(self): # this is instance method
        print ((self.m1+self.m2+self.m2)/3)
        #return (self.m1+self.m2+self.m2)/3
s1 = Student(67,89,56)
s2 = Student(54,65,84)

# print(s1.average())#Outside class
# print(s2.average())#outside class

----


==== class methods

- class methods are very rarely used methods in python
- Inside the method implemenation when we use static or class level variable then such type of methods are called methods
- While declering class methods we should pass class variable that is `cls`
- Using `cls` we can access static varibales inside the class methods
- In python to make any methods as class method then we use `@classmethod` decorator
- We can access (call) class method either by using classname or object reference
ex:
[source,python]
----
class Student:
    inst="cloudcatasyst" #static method
    def __init__(self,m1,m2,m3):
        self.m1=m1
        self.m2=m2
        self.m3=m3

    def average(self): # this is instance method
        print ((self.m1+self.m2+self.m2)/3)

    @classmethod
    def m1(cls):
        print(cls.inst)

#how to call cls method

s1 = Student(67,89,56)
s2 = Student(54,65,84)

s1.average()
s2.average()

Student.m1()
----
==== static methods

- These methods are general utility methods
- While declaring static methods we should not pass any `self` or `cls`
- To make method as static then we use `@staticmethod` decorator
- We can access static methods either by using `classname` or `object` reference


ex:
[source,python]
----
class Test:
    a = 100 #static variable

    def __init__(self):
        print("Inside the constructor")
        print(self.a) #using Inside the construtor
        print(Test.a)

    def m1(self):
        print("Inside the constructor")
        print(self.a) #using Inside the construtor
        print(Test.a)

    @classmethod
    def m2(cls):
        print("Inside the class mehtod")
        print(cls.a)
        print(Test.a)

    @staticmethod
    def m3():
        print("Inside the static method")
        print(Test.a)

t = Test()
t.m1()
t.m2()
t.m3()
print("Outside of the class")
print(t.a)
print(Test.a)
----


=== GC (Garbage collector)

- Automatic Memory management

==== How do we check GC is enabled or not
- isenabled(): true or false
- disable(): to disable GC explicitly
- enable(): to enable GC explicitly

ex:
[source,python]
----
import gc

print(gc.isenabled)
gc.disable()
print(gc.isenabled)
gc.enable()
print(gc.isenabled)

----

=== Destructor

destructor is a special method of class

----
destructor name is : __del__(self):

----

NOTE: it's only used to clean up active not for deleting object

EX:
[source,python]
----
import time

class Test:
    def __init__(self):
        print("Constructor execution")

    def __del___(self):
        print("Destructor execution")

t = Test()
time.sleep(3)
----


== Inner and Outer class mechanism
- Inside class, we can declare other class that called inner class
- Without existing one type of oject if there is no chance of existing another type of object then we use inner class
----
class Car:
     code...

     class Brain:
        code...
----



ex:
[source,python]
----
# inner class

class Outer:
    def __init__(self):
        print("Outer class constructor")

    def f1(self):
        print("Outer class method")

    class Inner:
        def __init__(self):
            print("Inner class constructor")

        def m1(self):
            print("Inner class method")

o = Outer()
o.f1()
i = o.Inner()
i.m1()
#or
i = Outer().Inner()
i.m1()
#or
Outer().Inner().m1()
Outer().f1()

----

IMPORTANT: X = 10 #public +
_ y = 20 #protected +
_ _ z = 30 #private

ex:
[source,python]
----
class Test:
    x = 10 #public
    _y = 20 #protected
    __z = 30 # private

    def __init__(self):
        print(self.x)
        print(self._y)
        print(self.__z)

t = Test()
print(t.x)
print(t._y)
# print(t.__z) #private variable not able to access and modifiy
----


=== Encapsulation

ex:
[source,python]
----
class Car:
    def __init__(self):
        self.__updatesoftware() # if we comment this line, we cant access __updatesoftware

    def __updatesoftware(self):
        print("Update car software")

c = Car()
c.__updatesoftware() # from here also not possibale becouse it private

----

ex:
[source,python]
----
class Car:
    __name=""
    __maxspeed=0 # try with maxspped you can access this

    def __init__(self):
        self.__name="figo"
        self.__maxspeed=100 # try with self.maxspped you can access this

    def drive(self):
        print("Car name")
        print("Driving with the speed:",self.__maxspeed) # try with self.maxspped you can access this

c = Car()
c.drive()
c.__maxspeed=200 #here we cant modify this becouse its private
# c.maxspeed=300 #here its public it can be accesable
c.drive()

----

=== How to implement inheritence

processing of creating new class form existing class.

- Exiting class as Base class or Parent class or Super class. +
- New class as Derived class or child class or sbu class

image::inheritence.jpg[inheritence and it's types]

. Single -> Create new class from single base class
. Multi level -> Creating new class from already derived class ( extensibility )
. Hierarchical -> Creating multiple child class from single parent class
. Multiple -> Is the process of Creating new class from two or more base classes
. Hybrid ->

==== isinstance():
Is used to check whether the object is an instance of particular class or not.






ex:
[source,python]
----
#isinstance()
class Parent:
    def p1(self):
        print("Parent class function")

class Child(Parent):
    def c1(self):
        print("Child class fucntion")

class Child2(Parent):
    def c2(self):
        print("Child2 class function")

obj1 = Child()
obj1.p1()
obj1.c1()

obj2 = Child2()
obj2.p1()
obj2.c2()

print(isinstance(obj1,Child2)) # Flase
print(isinstance(obj1,Child))
print(isinstance(obj2,Parent))

----

==== issubclass():
Is used to check the  class is a sub class of particular class or not.


ex:
[source,python]
----
class Parent:
    def p1(self):
        print("Parent class function")

class Child(Parent):
    def c1(self):
        print("Child class fucntion")

class Child2(Parent):
    def c2(self):
        print("Child2 class function")

obj1 = Child()
obj1.p1()
obj1.c1()

obj2 = Child2()
obj2.p1()
obj2.c2()

print(issubclass(Child,Parent))#True
print(issubclass(Child2,Parent))#True
print(issubclass(Child,Child2))#False
----


ex:
[source,python]
----
#parent (Single)
class Branch:
    def get_branch_data(self):
        self.bcode=int(input("Enter branch code:"))
        self.bname=input("Enter branch name:")
        self.baddress=input("Enter branch address:")

    def display_branch_data(self):
        print("Branch code is:",self.bcode)
        print("Branch name is:",self.bname)
        print("Branch addres is:",self.baddress)
#child
class Employee(Branch):
    def get_emp_data(self):
        self.empid=int(input("Enter emp id is:"))
        self.ename=input("Enter ename:")
        self.eaddress=input("Enter eaddress:")

    def display_emp_data(self):
        print("Emp ID is:",self.empid)
        print("Emp name is:",self.ename)
        print("Emp address is:",self.eaddress)

# b= Branch()
# b.get_branch_data()
# b.display_branch_data()


# e= employee()
# e.get_emp_data()
# e.display_emp_data()

e = Employee()
e.get_branch_data()
e.get_emp_data()
e.display_branch_data()
e.display_emp_data()
----


ex:
[source,python]
----

----



ex:
[source,python]
----
#parent (Multi level inheritence)
class Branch:
    def get_branch_data(self):
        self.bcode=int(input("Enter branch code:"))
        self.bname=input("Enter branch name:")
        self.baddress=input("Enter branch address:")

    def display_branch_data(self):
        print("Branch code is:",self.bcode)
        print("Branch name is:",self.bname)
        print("Branch addres is:",self.baddress)
#child
class Employee(Branch):
    def get_emp_data(self):
        self.empid=int(input("Enter emp id is:"))
        self.ename=input("Enter ename:")
        self.eaddress=input("Enter eaddress:")

    def display_emp_data(self):
        print("Emp ID is:",self.empid)
        print("Emp name is:",self.ename)
        print("Emp address is:",self.eaddress)
#child
class Empsalary(Employee):
    def get_sal(self):
        self.basic=int(input("Enter basic salary:"))

    def calculate(self):
        self.DA=self.basic*0.03
        self.HRA=self.basic*0.4
        self.Gross=self.basic+self.DA+self.HRA

    def displaysal(self):
        print("Basic is :",self.basic)
        print("DA is :",self.DA)
        print("HRA is:",self.HRA)
        print("Gross salary is:",self.Gross)


e = Empsalary()
e.get_branch_data()
e.get_emp_data()
e.get_sal()
e.calculate()
e.display_branch_data()
e.display_emp_data()
e.displaysal()

----

ex:
[source,python]
----
#Hierarchical
class Parent:
    def p1(self):
        print("Parent class function")

class Child(Parent):
    def c1(self):
        print("Child class fucntion")

class Child2(Parent):
    def c2(self):
        print("Child2 class parent")

obj1 = Child()
obj1.p1()
obj1.c1()

obj2 = Child2()
obj2.p1()
obj2.c2()
----

ex:
[source,python]
----
#Multiple inheritence
class A:
    def f1(self):
        print("F1 function of class A ")

class B:
    def f2(self):
        print("F2 function of class B")

class C(A,B):
    def f3(self):
        print("F3 function of class C")

c = C()
c.f1()
c.f2()
c.f3()



#or
#MRO(Method Resolution Order)
class A:
    def f1(self):
        print("F1 function of class A ")

class B:
    def f1(self):
        print("F2 function of class B")

class C(B,A): # here change order like (A,B) it will take based on order
    def f3(self):
        print("F3 function of class C")

c = C()
c.f1()
c.f3()

#output of (B,A) here if f2 function is not there it will take f1 function
#F2 function of class B
#F3 function of class C
#output of (A,B) here if f1 function is not there it will take f2 function
#F1 function of class A
#F3 function of class C
----

EX:
[source,python]
----
#MRO(Method Resolution Order)
class A:
    def f1(self):
        print("F1 function of class A ")

class B:
    def f1(self):
        print("F2 function of class B")

class C(B,A):
    def f3(self):
        print("F3 function of class C")

class D(C):
    def f4(self):
        A.f1(self)
        print("F4 function of class D")


d = D()
d.f1()
d.f3()
d.f4()
----

=== Polymorphism

==== Type of Polymorphism

1. Static or Compile time -- overloading (Refinement Technique )
2. Dynamic or Runtime -- Overriding (Replacement Technique)


==== Overloading

1. operator overloading -- yes (Python support)
2. method Overloading  -- NO  (Python Will not support)
3. constructor overloading -- NO

==== overriding

1. method overriding  -- YES
2. constructor overriding -- YES


In Python every operator is having magic method

[cols="2,2", options="header"]
|===
| Symbol | Operation

| +
| _ _ add _ _

| -
| _ _ sub _ _

| *
| _ _ mul _ _

| /
| _ _ div _ _

| **
| _ _ pow _ _

| <
| _ _ lt _ _

| < =
| _ _ lte _ _
|===


ex:
[source,python]
----
#oerator overloading need to include  magic methods
class Book:
    def __init__(self,pages):
        self.pages=pages

    def __add__(self, other):
        return self.pages+other.pages

b1 = Book(10)
b2 = Book(20)

print(b1+b2)
----

==== method overriding

Whatever the members are available in the parent class that are by default available to child class to inheritance  +

If child class not satisfy with parent class implementation then child class can redefine the parent class methods this process is called overriding ( Dynamic )


ex:
[source, python]
----
#method overrding
class Parent:
    def assets(self):
        print("cash+gold+lands")

    def car(self):
        print("Alto car")

class Child(Parent):
    def car(self):
        super().car()
        print("Benz car")

c = Child()
c.assets()
c.car()
----

==== constructor overriding

ex:
[source, python]
----
#constructor overrding
class Parent():
    def __init__(self):
        print("Parent class constructor")

class Child(Parent):
    def __init__(self):
        super().__init__() #if you want to call both we need to use super method
        print("Child class constructor")

c = Child()
----

==== Abstract Methods
. A method which do not any implementation, which contain only declaration or signature is called abstract method
. To make a method as Abstract then, we use @abstractmethod decorator
. Abstract method should be overridden
. To leave abstract method  empty as we use pass keyword
----
@abstractmethod
def m1(self):
    pass
----
==== Abstract class

. A class which is having one or more abstract method is called abstract class
. Abstract class aslo contain non-abstract methods
. Abstract class contain partial implementation
. Abstract class can't instantiate (object creatain) directly so that we need to create or derive new class from abstract class to provide functionality to it;s abstract function
. We can't create object for abstract class.
. To make a class as abstract then that class should inherit from predefined abstract base class i.e ABC
. Abstract method decorator and ABC are present in abc module

----
from abc import ABC,abstractmethod
class Test(ABC):
{
@abstractmethod
def m1(self):
    pass
----



ex:
[source, python]
----
from abc import ABC,abstractmethod

class Vehicle(ABC):
    @abstractmethod
    def wheels(self):
        pass

    def enginetype(self):
        print("BS-6 Engine")

    @abstractmethod
    def colour(self):
        pass

class Car(Vehicle):
    def wheels(self):
        print("Car: 4 wheels")
    def colour(self):
        print("Bike: clour is red")


class Bike(Vehicle):
    def wheels(self):
        print("Bike: 2 wheels")
    def colour(self):
        print("Car: clour is block")

# v = Vehicle()

c = Car()
c.wheels()
c.enginetype()
c.colour()

b = Bike()
b.wheels()
b.enginetype()
c.colour()

----

== Exception Handling Mechanism:

Exception means an unexpected or unwanted event will disturb tha normal floe of program exception is called exception

Exception is a super class of all sub class Exception

=== Class of Exception
. name error
. value error
. type error
. zero division error
. file not found error
. file exist error.. ect...


1. **Syntactical errors** : wrong spelling to the syntax like **()** , **" "**, **:**
2. **Runtime errors** : Abnoraml termination of program execution

==== What are exception handling methods

1. Logical implementation
2. try except implementation



ex:
[source, python]
----
#syntax errors
a = 10
print(A)
#Output
# NameError: name 'A' is not defined. Did you mean: 'a'?


a= int(input("Enter a number:"))
#Output
#    a= int(input("Enter a number:"))
#ValueError: invalid literal for int() with base 10: 'fghfg'


print(10+"cloud")
#Output
# TypeError: unsupported operand type(s) for +: 'int' and 'str'

print(10/0)
#Output
# ZeroDivisionError: division by zero

----

==== Logical implementation

ex:
[source, python]
----
#Logical implementation
a = int(input("Enter num1:"))
b = int(input("Enter num2:"))
if b == 0 :
    print("Second number can't be Zero(0)")
else:
    c = a/b
    print("Result is:")
----
==== try except implementation

==== two type of except block
1. default block
Except block without any exception class

2. specific block
Except block with any exception class.
----
try:
    statements #risky code
except:
    statements #handling code
----

ex:
[source, python]
----
#default except block
try:

    a = int(input("Enter num1:"))
    b = int(input("Enter num2:"))
    c = a/b
    print("Result is:",c)
except:
    print("something went wrong")

----

ex:
[source, python]
----
#specific except block
try:

    a = int(input("Enter num1:"))
    b = int(input("Enter num2:"))
    c = a/b
    print("Result is:",c)
except (ZeroDivisionError,ValueError) as message:
    print(message)
# except ValueError as msg:
#     print(msg)

----

ex:
[source, python]
----
#Exception is a super class of all sub class Exception
try:

    a = int(input("Enter num1:"))
    b = int(input("Enter num2:"))
    c = a/b
    print("Result is:",c)
except Exception as message:
    print(message)

----

ex:
[source, python]
----
#specific and defalut except block
try:

    a = int(input("Enter num1:"))
    b = int(input("Enter num2:"))
    c = a/b
    print("Result is:",c)
except ZeroDivisionError as message:
    print(message)
except: #defalut except block
    print("something went wrong") # defalut except block must be last

----

----
try:
    statement1
    statement2
    statement3
except:
    statement4
statement5
----


ex:
[source, python]
----
next video 32

----