// = Terraform Overview
//
// == Q1. What do you understand by Terraform in AWS?
// Terraform is a part of the AWS DevOps Competency and is also an AWS Partner Network (APN) advanced technology partner. It is similar to AWS CloudFormation in the sense that it is also an “infrastructure as code” tool that allows you to create, update, and version your AWS infrastructure.
//
// == Q2. What are the key features of Terraform?
// Terraform helps you manage all of your infrastructure as code and construct it as and when needed. Here are its key main features:
// - A console that allows users to observe functions
// - The ability to translate HCL code into JSON format
// - A configuration language that supports interpolation
// - A module count that keeps track of the number of modules applied to the infrastructure.
//
// == Q3. Define IAC?
// IAC or Infrastructure as Code allows you to build, change, and manage your infrastructure through coding instead of manual processes. The configuration files are created according to your infrastructure specifications, and these configurations can be edited and distributed securely within an organization.
//
// == Q5. What are the most useful Terraform commands?
// Some of the most useful Terraform commands are:
// - `terraform init` - initializes the current directory
// - `terraform refresh` - refreshes the state file
// - `terraform output` - views Terraform outputs
// - `terraform apply` - applies the Terraform code and builds stuff
// - `terraform destroy` - destroys what has been built by Terraform
// - `terraform graph` - creates a DOT-formatted graph
// - `terraform plan` - a dry run to see what Terraform will do
//
// == Q6. Are callbacks possible with Terraform on Azure?
// By using the Azure Event Hubs, callbacks are possible on Azure. Terraform’s Azure provider offers effortless functionality to users. Microsoft Azure Cloud Shell provides an already-installed Terraform instance.
//
==  What is Terraform init?
`terraform init` is a command to initialize an operational directory that contains Terraform configuration files. This command can be run multiple times. It is the first command that should be executed after writing new Terraform configurations.

==  What is Terraform D?
`Terraform D` is a plugin used on most in-service systems and Windows. `terraform init` by default searches the following directories for plugins.

// == Q9. Is history the same as it is on the web while using TFS API to provide resources?
// Yes, the history is similar to what is available on the web because the UI relies on the API as the base. The information displayed in the UI is available through other methods and the API.
//
// == Q10. Why is Terraform used for DevOps?
// Terraform uses a JSON-like configuration language called HashiCorp Configuration Language (HCL). HCL has a very simple syntax that makes it easy for DevOps teams to define and enforce infrastructure configurations across multiple clouds and on-premises data centers.
//
==  Define null resource in Terraform.
`null_resource` implements the standard resource library, but no further action is taken. The `triggers` argument allows an arbitrary set of values that will cause the replacement of resources when changed.

// == Q12. What do you mean by Terraform Cloud?
// Terraform Cloud is a platform that enables teams to use Terraform together, either on-demand or in response to various events. It is deeply integrated with Terraform's workflows and data, unlike a general-purpose continuous integration system. It includes easy access to shared state and secret data, detailed policy controls for updating infrastructure and governing the contents of Terraform, a private registry for sharing Terraform modules, and much more.
//
==  What do you understand by the terraform backend?
Each Terraform configuration can specify a backend, which defines two main things:
- Where operations are performed
- Where the state is stored (Terraform keeps track of all the resources created in a state file)

//
// == Q13. What are the version controls supported by Terraform besides GitHub?
// The version controls supported by Terraform include:
// - GitLab EE
// - GitLab CE
// - Bitbucket Cloud
//
// == Q14. Name some major competitors of Terraform.
// Some of the top competitors and alternatives to Terraform are:
// - Azure Management Tools
// - Morpheus
// - CloudHealth
// - Turbonomic
// - CloudBolt
//
// == Q15. Explain the uses of Terraform CLI and list some basic CLI commands.
// The Terraform Command-Line Interface (CLI) is used to manage infrastructure and interact with Terraform state, configuration files, providers, etc. Here are some basic CLI commands:
// - `terraform init` - initializes the current directory
// - `terraform refresh` - refreshes the state file
// - `terraform output` - views Terraform outputs
// - `terraform apply` - applies the Terraform code and builds stuff
// - `terraform destroy` - destroys what has been built by Terraform
// - `terraform graph` - creates a DOT-formatted graph
// - `terraform plan` - a dry run to see what Terraform will do
//
// == Q16. What are modules in Terraform?
// A module in Terraform is a container for multiple resources that are used together. The root module includes resources defined in the `.tf` files and is required for every Terraform configuration.
//
// == Q17. What is a Private Module Registry?
// A Private Module Registry is a feature from Terraform Cloud that allows users to share Terraform modules across the organization. You can enforce rules or “Sentinel policies” on the registry that specify how members of your organization can use the modules.
//
// == Q18. Is Terraform usable for on-prem infrastructure?
// Yes, Terraform can be used for on-prem infrastructure. With a variety of available providers, you can choose the one that best suits your needs. All that is required is an API.
//
// == Q19. Does Terraform support multi-provider deployments?
// Yes, Terraform supports multi-provider deployments, including on-premises solutions like OpenStack and VMware. Terraform can also manage Software-Defined Networking (SDN).
//
// == Q20. How is duplicate resource error ignored during terraform apply?
// To handle duplicate resource errors, you can try the following options:
// - Delete those resources from the cloud provider (API) and recreate them using Terraform.
// - Remove those resources from the Terraform code to stop managing them.
// - Perform a `terraform import` of the resource and remove the code that is trying to recreate them.
//
// == Q21. What are the various version controls supported by Terraform?
// The supported version controls are:
// - Azure DevOps Services
// - Azure DevOps Server
// - Bitbucket Server
// - Bitbucket Cloud
// - GitLab EE and CE
// - GitLab.com
// - GitHub Enterprise
// - GitHub.com (OAuth)
// - GitHub.com
//
// == Q22. What are some of the built-in provisioners available in Terraform?
// Here is the list of built-in provisioners in Terraform:
// - Salt-masterless Provisioner
// - Remote-exec Provisioner
// - Puppet Provisioner
// - Local-exec Provisioner
// - Habitat Provisioner
// - File Provisioner
// - Chef Provisioner
//
// == Q23. Which command destroys Terraform managed infrastructure?
// The command used for this purpose is:
// `terraform destroy [options] [dir]`
//
// == Q24. Tell us about some notable Terraform applications.
// The applications of Terraform are broad due to its capability to extend its abilities for resource manipulation. Some notable applications are:
// - Software demos development
// - Resource schedulers
// - Multi-cloud deployment
// - Disposable environment creation
// - Multi-tier application development
// - Self-service clusters
// - Setup of Heroku App
//
// == Q25. What are the components of Terraform architecture?
// The Terraform architecture includes the following components:
// - Sub-graphs
// - Expression Evaluation
// - Vertex Evaluation
// - Graph Walk
// - Graph Builder
// - State Manager
// - Configuration Loader
// - CLI (Command Line Interface)
// - Backend
//
// == Q26. Define Resource Graph in Terraform.
// A resource graph is a visual representation of the resources. It helps modify and create independent resources simultaneously. Terraform uses the resource graph to generate plans and refresh the state, creating structure most efficiently to help understand dependencies and potential issues.
//
// == Q27. Can you provide a few examples where Sentinel policies can be used?
// Sentinel policies are a powerful way to implement various policies in Terraform. Here are a few examples:
// - Enforce explicit ownership in resources
// - Restrict roles the cloud provider can assume
// - Review an audit trail for Terraform Cloud operations
// - Forbid only certain resources, providers, or data sources
// - Enforce mandatory tagging on resources
// - Restrict how modules are used in the Private Module Registry
//
// == Q28. What are the various levels of Sentinel enforcement?
// Sentinel has three enforcement levels:
// - Advisory: Logged but allowed to pass. An advisory is issued to the user when they trigger a plan that violates the policy.
// - Soft Mandatory: The policy must pass unless an override is specified. Only administrators have the ability to override.
// - Hard Mandatory: The policy must pass no matter what. This policy cannot be overridden unless it is removed. It is the default enforcement level in Terraform.
//
//
//
// == Q27. How to Store Sensitive Data in Terraform?
//
// Terraform requires credentials to communicate with your cloud provider's API. But most of the time, these credentials are saved in plaintext on your desktop. GitHub is exposed to thousands of API and cryptographic keys every day. Hence, your API keys should never be stored in Terraform code directly. You should use encrypted storage to store all your passwords, TLS certificates, SSH keys, and anything else that shouldn't be stored in plain text.
//
// == Q28. What is Terragrunt, and what are its uses?
//
// Terragrunt is a thin wrapper that provides extra tools to keep configurations DRY, manage remote state, and work with multiple Terraform modules. It is used for:
// * Working with multiple AWS accounts
// * Executing Terraform commands on multiple modules
// * Keeping our CLI flags DRY
// * Keeping our remote state configuration DRY
// * Keeping our Terraform code DRY
//
// == Q29. Explain State File Locking
//
// State file locking is a Terraform mechanism in which operations on a specific state file are blocked to avoid conflicts between multiple users performing the same process. When one user releases the lock, then only the other one can operate on that state. This helps in preventing state file corruption. This is a backend operation.
//
// == Q30. What do you understand by a Tainted Resource?
//
// A tainted resource is a resource that is forced to be destroyed and recreated on the next command. When a resource is marked as tainted, the state files are updated, but nothing changes on the infrastructure. The `terraform plan` shows that it will be destroyed and recreated. The changes get implemented when the next `terraform apply` happens.
//
// == Q31. How to lock Terraform module versions?
//
// A proven way of locking Terraform module versions is using the Terraform module registry as a source. We can use the `version` attribute in the module of the Terraform configuration file. As the GitHub repository is being used as a source, we need to specify versions, branch, and query strings with `?ref`.
//
// == Q32. What is Terraform Core?
//
// Terraform Core is a binary written statically compiled by using the Go programming language. The compiled binary offers an entry point for the users of Terraform. The primary responsibilities include:
// * Reading and interpolation of modules and configuration files by Infrastructure as code functionalities
// * Resource Graph Construction
// * Plugin communication through RPC
// * Plan execution
// * Management of resource state
//
// == Q33. Give the Terraform configuration for creating a single EC2 instance on AWS.
//
// This is the Terraform configuration for creating a single EC2 instance on AWS:
//
// [source,hcl]
// ----
// provider "aws" {
//   region = ""
// }
//
// resource "aws_instance" "example" {
//   ami           = "ami-213123585"
//   instance_type = "t2.micro"
//
//   tags = {
//     Name = "example"
//   }
// }
// ----
//
// == Q34. How will you upgrade plugins on Terraform?
//
// Run `terraform init` with the `-upgrade` option. This command rechecks the releases.hashicorp.com to find new acceptable provider versions. It also downloads available provider versions. `.terraform/plugins/_` is the automatic downloads directory.
//
// == Q35. How will you make an object of one module available for the other module at a high level?
//
// An output variable is defined in resource configuration. Declare the output variable of `module_A`. Create a file `variable.tf` for `module_B`. Establish the input variable inside this file having the same name as the key defined in `module_B`. Replicate the process for making variables available to other modules.
//
// == Q36. What are some of the latest Terraform Azure Provider factors?
//
// The latest versions involve new data resources and `azurerm_batch_certificate`, which helps in managing the certificate. This resource is used for controlling the prefix in networking. There are fixes for bugs, and `azurerm_app_service` has also been enhanced.
//
// == Q37. How will you control and handle rollbacks when something goes wrong?
//
// I need to recommit the previous code version to be the new and current version in my VCS. This would trigger a Terraform run, which would be responsible for running the old code. As Terraform is more declarative, I will make sure all things in the code roll back to the old code. I would use the State Rollback Feature of Terraform Enterprise to roll back to the latest state if the state file got corrupted.

== Basic Terraform Interview Questions and Answers

=== Question 1: What is Terraform?

Answer: Terraform is open-source communication as a system software tool created by HashiCorp. It is an instrument for building, altering, and versioning transportation safely and professionally. Terraform can direct existing and accepted service providers as well as convention in-house solutions.

=== Question 2: Why you should use Terraform?

Terraform is a tool to build an infrastructure safely and efficiently. Terraform can manage leading and popular service providers as well as custom in-house solutions.

image::terraform-config-files.png[]

Terraform uses

The Configuration file in Terraform describes the components needed to run a single application or your entire data centre. Terraform then generates an execution plan describing what it will do to reach the desired state, and then executes it to build the described infrastructure. It creates incremental execution plans which can be applied according to the configuration change.

=== Question 3: What are the reasons for choosing Terraform for DevOps?


Answer: Below are the reasons for choosing Terraform for DevOps:

  -  It can do complete orchestration and not just configuration management (like Ansible and Puppet).Has amazing support of almost all the popular cloud providers like AWS, Azure, GCP, DigitalOcean etc.
  -  Easily manages the configuration of an immutable (dynamic) infrastructure.
  -  Provide immutable infrastructure where configuration changes smoothly.
   - Works on HCL (HashiCorp configuration language), which is very easy to learn and understand.
   - Easily portable from one provider to another.
   - Easy Installation.

Get the FREE Terraform Interview Questions & Answers Guide for download.

=== Question 4: What do you mean by Terraform init?

Answer: Terraform initialises the code with the command terraform init. This command is used to set up the working directory for Terraform configuration files. It is safe to run this command multiple times.

You can use the init command for:

  -  Installing Plugins
  -  Installation of a Child Module
   - Initialization of the backend

=== Question 5: Name some major competitors of Terraform?

Answer: Some of them are:

  -  Packer
  -  Cloud Foundry
  -  Ansible
  -  Kubernetes

=== Question 6: What is Terraform provider?

Answer: Terraform is a tool for managing and informing infrastructure resources such as physical machines, virtual machines (VMs), network switches, containers, and more. A provider is responsible for API interactions that are thoughtful and reveal resources. Terraform is compatible with a wide range of cloud providers.

=== Question 7: How does Terraform work?

Answer: Terraform creates an implementation plan, defines what it will do to achieve the desired state, and then executes it to build the infrastructure described. Terraform is capable of determining what changed and generating incremental execution plans that are practical as the configuration changes.

=== Question 8: What are the features of Terraform?

Answer: Some of them are:

  -  Execution Plan
  -  Change Automation
   - Resource Graph
   - Infrastructure as code

==== Question 9: What do you mean by IaC?

Answer: IaC is a short form to the term “Infrastructure as Code”. IaC refers to a scheme whereby developers can run and provision the computer data center’s mechanically instead of getting into a physical process. Terraform IAC, for example, is a case tool of IAC.

=== Question 10: Describe the working of Terraform core?
Answer: The terraform core examines configuration monitoring and generates configuration-based analysis and evaluation. It keeps track of and compares versions (current and previous) before displaying the results via the terminal.

Terraform core mainly takes two inputs:

 -   Terraform Configuration – It keeps track of the infrastructure detail
 -   Terraform state – It keeps track of the infrastructure status.

=== Question 11:  What are the key features of Terraform?

Answer: Following are the key features of Terraform:

  -  Infrastructure as Code: Terraform’s high-level configuration language is used to define your infrastructure in human-readable declarative configuration files.
  -  You may now create an editable, shareable, and reusable blueprint.
  -  Terraform generates an execution plan that specifies what it will do and asks for your approval before making any infrastructure alterations. You can assess the modifications before Terraform creates, updates, or destroys infrastructure.
  -  Terraform creates a resource graph while simultaneously developing or altering non-dependent resources. Terraform can now build resources as quickly as possible while also giving you more information about your infrastructure.
  -  Terraform’s the automation of change allows you to apply complex changesets to your infrastructure with little to no human interaction. Terraform recognises

=== Question 12: What are the use cases of Terraform?
Following are the use cases of Terraform:

Setting Up a Heroku App:

  -  Heroku is a popular platform as a service for hosting web applications (PaaS). Developers first create an app, then add add-ons such as a database or an email service. One of the best features is the ability to scale the number of dynos or workers as needed. Most non-trivial applications, on the other hand, quickly necessitate a large number of add-ons and external services.
  -  Terraform can be used to codify the configuration of a Heroku application, ensuring that all necessary add-ons are present, but it can also go beyond, such as configuring DNSimple to set a CNAME or Cloudflare as the app’s CDN. Best of all, Terraform can accomplish all of this in under 30 seconds without the use of a web interface.

Kaffeine

Clusters of Self-Service:

   - A centralised operations team overseeing a large and expanding infrastructure becomes extremely difficult at a certain organisational level. Implementing “self-service” infrastructure, which allows product teams to manage their own infrastructure using tooling provided by the central operations team, becomes more appealing.
  -  Terraform configuration can be used to keep track of how a service is built and scaled. You can then share these settings with the rest of your company, allowing client teams to manage their services using Terraform.
Quick Creation of Environments:

   - It is common to have both a production and a staging or quality assurance environment. These environments are miniature versions of their production counterparts, and they are used to test new programmes before they are released to the public. Maintaining an up-to-date staging environment becomes increasingly difficult as the production environment grows larger and more involved.
  -  Terraform can be used to codify and share the production environment with staging, QA, and development. These parameters can be quickly used to create new testing environments that can be easily discarded. Terraform, which allows parallel environments to be created and destroyed on the fly, can help to alleviate the difficulty of maintaining them.
Schedulers of Resources:

   - Static application assignment to computers becomes increasingly difficult in large-scale infrastructures. Among the schedulers that can help with this challenge are Borg, Mesos, YARN, and Kubernetes. These can be used to schedule Docker containers, Hadoop, Spark, and a variety of other software applications dynamically.
   - Terraform isn’t just for Amazon Web Services and other physical service providers. Terraform can request resources from resource schedulers because they can be viewed as providers. Terraform can now work in layers, such as deploying the physical infrastructure that powers the schedulers and provisioning into the scheduled grid.
Demonstrations of software:

  -  In today’s world, software is becoming increasingly networked and distributed. Although virtualized demo environments can be created with tools such as Vagrant, displaying software on real infrastructure that closely replicates production environments remains difficult.
  -  A Terraform configuration can be used by software authors to design, provision, and bootstrap a demo on cloud providers such as AWS. End users can simply demo the application on their own infrastructure, and configuration options such as cluster size can be changed to evaluate tools at any scale.

===  13: How to check the installed version of Terraform?

Answer: We can use terraform -version of the command to identify the version which we are running.

== Intermediate Terraform Interview Questions

=== Question 14: What are the most useful Terraform commands?

image::Terraform_Workflow.jpg[]

Common commands:

    terraform init: Prepare your working directory for other commands
    terraform plan: Show changes required by the current configuration
    terraform apply: Create or update infrastructure
    terraform destroy: Destroy previously-created infrastructure


=== Question 15: How does Terraform help in discovering plugins?

Answer: Terraform interprets configuration files in the operational directory with the authority “Terraform init.” Then, Terraform determines the necessary plugins and searches for installed plugins in various locations. Terraform may also download additional plugins at times. Then it decides which plugin versions to use and creates a security device file to ensure that Terraform uses the same plugin versions.

=== Question 16: Can I add policies to the open-source or pro version of Terraform enterprise?

Answer: Terraform Policies cannot be added to Terraform Enterprise’s open-source description. The same is true for the Enterprise Pro edition. Terraform Enterprise’s best version could only contact the watch policies.

=== Question 17: Define Modules in Terraform?

Answer: A module in Terraform is a container for multiple resources that are used in tandem. Every Terraform that includes resources mentioned in.tf files requires the root module.

=== Question 18: What are the ways to lock Terraform module versions?

Answer: You can use the terraform module registry as a source and specify the attribute’version’ in the module in a terraform configuration file. If you are using the GitHub repository as a source, you must use ‘? ref’ to specify the branch, version, and query string.

=== Question 19: What do you mean by Terraform cloud?

Answer: Terraform Cloud is an application that enables teams to use Terraform collaboratively. It manages Terraform runs in a consistent and reliable environment, and includes features such as easy access to shared state and secret data, access controls for approving infrastructure changes, a private registry for sharing Terraform modules, detailed policy controls for governing the contents of Terraform configurations, and more.

=== Question 20: Define null resource in Terraform?

Answer: The null resource follows the standard resource lifecycle but takes no additional actions. The trigger argument allows for the specification of a subjective set of values that, if misrepresented, will cause the reserve to be replaced.

The null resource’s primary application is as a do-nothing container for arbitrary actions performed by a provisioner.

=== Question 21: Can Terraform be used for on-prem infrastructure?

Answer: Yes, Terraform can be used to build on-premises infrastructure. There are numerous providers available. You can select whichever one best suits your needs. Many people create client Terraform providers for themselves; all that is required is an API.

=== Question 22 : What does the following command do?

Answer:

    Terraform -version – to check the installed version of terraform
    Terraform fmt– it is used to rewrite configuration files in canonical styles and format
    Terraform providers – it gives information of providers working in the current configuration.

=== Question 23: List all the Terraform-supported versions
Answer:

    GitHub.com
    GitLab.com
    GitHub Enterprise
    GitLab CE and EE
    Bitbucket Cloud and Server
    Azure DevOps Server and Services

=== Question 24: Explain the command terraform validate in the context of Terraform.
Answer: The terraform validate command examines the configuration files in a directory, concentrating solely on the configuration and ignoring any external services such as remote state, provider APIs, and so on. Validate inspects a configuration to determine whether it is syntactically correct and internally consistent, regardless of variables or current state. As a result, it’s best for general reusable module verification, such as confirming the validity of attribute names and value types. This command can be executed automatically, such as a post-save check in a text editor or a test step in a continuous integration system for a reusable module.
Syntax: terraform validate [options]

=== Question 25: Mention some of the version control tools supported by Terraform.
Answer: Version control tools supported by Terraform are:

    GitHub
    GitLab CE
    GitLab EE
    Bucket Cloud

== Advanced Terraform Interview Questions
=== Question 26: How would you recover from a failed apply in Terraform?

Answer: You can save your configuration in version control and commit it before making any changes, and then use the features of your version control system to revert to an earlier configuration if necessary. You must always recommit the previous version code in order for it to be the new version in the version control system.

=== Question 27: What do you mean by Terragrunt, list some of its use cases?

Answer: Terragrunt is a lightweight wrapper that adds tools for maintaining DRY configurations, working with multiple Terraform modules, and managing remote states.

Use cases:

    Keep your Terraform code DRY
    Maintain a DRY remote state configuration.
    Keep your CLI flags DRY
    Run Terraform commands on multiple modules at the same time.
    Use multiple AWS accounts.

=== Question 28: What steps should be followed for making an object of one module to be available for the other module at a high level?

Answer: The following are the steps to take in order to make an object from one module available to the other module at a high level:

    First, in a resource configuration, an output variable must be defined. The scope of local and to a module is not declared until you declare resource configuration details.
    You must now declare the output variable of module A so that it can be used in the configurations of other modules. You should create a brand new and current key name, and the value should be kept equal to the module A output variable.
    You must now create a file variable.tf for module B. Create an input variable inside this file with the same name as the key you defined in module B. This variable in a module enables the resource’s dynamic configuration. Rep the process to make this variable available to another module as well. This is due to the fact that the variable established here has a scope limited to module B.

=== Question 29: What is State File Locking?

Answer: State file locking is a Terraform mechanism that prevents operations on a specific state file from being performed by multiple users at the same time. Once the lock from one user is released, any other user who has taken a lock on that state file can operate on it. This aids in the prevention of state file corruption. The acquiring of a lock on a state file in the backend is a backend operation. If acquiring a lock on the state file takes longer than expected, you will receive a status message as an output.
Question 30: What is a Remote Backend in Terraform?

Answer: Terraform remote backend is used to store Terraform’s state and can also run operations in Terraform Cloud. Multiple terraform commands such as init, plan, apply, destroy (terraform version >= v0.11.12), get, output, providers, state (sub-commands: list, mv, pull, push, rm, show), taint, untaint, validate, and many more are available via remote backend. It is compatible with a single remote Terraform cloud workspace or multiple workspaces. You can use terraform cloud’s run environment to run remote operations such as terraform plan or terraform apply.

=== Question 31: What is a Tainted Resource?

Answer: Tainted resources are those that must be destroyed and recreated upon the next apply command. Nothing changes on infrastructure when you mark a resource as tainted, but the state file is updated with this information (destroy and create). After marking a resource as tainted, Terraform plan out will show that the resource will be destroyed and recreated, and the changes will be implemented when the next apply occurs.


===  Question 32: Are callbacks possible with Terraform on Azure?
Answer: Terraform uses Azure Event Hub to perform Azure callbacks. It aids in achieving functionality such as sending a callback to the system and other events. To make the process easier, Terraform AzureRM already includes this functionality.

=== Question 33: How to prevent Error Duplicate Resource
Answer: It can be done in three ways depending on the situation and the requirement
1) By deleting the resource, Terraform code will no longer manage it.
2) By removing resources from APIs
3) Importing action will also aid in resource elimination.

=== Question 34: Explain the workflow of the core terraform.
Answer: Terraform’s core workflow has three steps:

    Write – Create infrastructure in the form of code.
    Plan – Plan ahead of time to see how the changes will look before they are implemented.
    Apply – Create a repeatable infrastructure.

image::core_terraform_workflow.png[]

=== Question 35: Explain the architecture of Terraform request flow.

Answer: A request in Terraform undergoes the following steps as shown in the diagram:

image::Terraform_request_flow.png[]

Command Line Interface (CLI):

CLI (Common Language Interface) (command package)

Except for some early bootstrapping in the root package, when a user launches the terraform programme, execution immediately jumps into one of the command package’s “command” implementations (not shown in the diagram). The commands store the mapping between user-facing command names and their corresponding command package types. The go file is located in the repository’s root directory.

The command implementation’s responsibility for these commands is to read and parse any command line arguments, command-line options, and environment variables required for the specified command and use them to construct a backend. object of operation The operation is then passed to the currently selected backend.

Backends:

A backend in Terraform is responsible for a number of things:

    Execute operations (e.g. plan, apply)
    Variables defined in the workspace can be saved.
    to store the current state

The local backend retrieves the current state for the workspace specified in the operation using a state manager (either statemgr.Filesystem if the local backend is used directly, or an implementation provided by whatever backend is being wrapped), and then uses the config loader to load and perform initial processing/validation of the configuration specified in the operation. It then creates a terraform.context object using these parameters as well as the other parameters supplied in the process. The main object performs terraform operations.

Configuration Loader :

Model types represent the top-level configuration structure in package configs. Config represents a configuration (the root module and all of its child modules). Although the configs package contains some low-level functionality for creating configuration objects, the configload is the primary entry point. Loader can be found in the configload subpackage. A loader handles all of the complexities associated with installing child modules (during terraform init) and then locating those modules when a configuration is loaded by a backend. It takes the path to the root module and loads all of the child modules recursively to produce a single configuration.

State Manager:

The state manager is in charge of storing and retrieving snapshots of a workspace’s Terraform state. Each manager implements a subset of the interfaces provided by the statemgr package, with the majority of managers covering the entire set of statemgr. Complete operation. The smaller interfaces are commonly used in other function signatures to specify what actions the function may take on the state manager; there is no reason to create a state manager that does not implement all of statemgr. Full.

Graph Builder:

The terrain. The Context method calls a graph builder. A graph builder is used to represent the fundamental phases of that action, as well as the dependencies between them. Because of the differences in the graph-building process, each operation has its own graph builder. For a “plan” operation, a graph must be constructed directly from the configuration, whereas a “apply” action constructs its graph from the set of alterations mentioned in the plan being applied.

Graph Walk:

The graph walking method explores each vertex of the graph while keeping the graph’s “happens after” edges in mind. Every vertex in the graph is evaluated so that the “happens after” edges are taken into account. The graph walk algorithm will evaluate multiple vertices at once if possible.

Vertex Evaluation:

Execution refers to the action taken for each vertex during a graph walk. Execution performs a set of random operations that are appropriate for the vertex type in question. Before the graph walk can begin evaluating other vertices with “happens after” edges, a vertex must be correctly completed. When one or more errors occur during evaluation, the graph walk is paused, and the errors are returned to the user. questions for terraform interviews

=== Question 36: Differentiate between Terraform and Cloudformation.
Answer: The following points highlight the differences between Terraform and Cloudformation :AWS Infrastructure As Code: CloudFormation vs Terraform | by Jackie Tung | Medium

image::cloudforamation_vs_terraform.png[]

    User-friendliness: Terraform works with a variety of Cloud Service Providers, including AWS, Azure, Google Cloud Platform, and others, whereas CloudFormation only works with AWS services. Terraform covers the vast majority of AWS resources.
    Depending on the language: CloudFormation supports JSON and YAML. CloudFormation is now simple to grasp and apply. AWS developers, on the other hand, are not permitted to create CloudFormation templates larger than 51MB. If the size of a template exceeds this limit, the developers must create a layered stack for it.
    Terraform, on the other hand, makes use of Hashicorp’s own HCL programming language (Hashicorp Configuration Language). This language is also JSON-compatible.
    State-management:
        Because CloudFormation is an AWS managed service, it inspects the infrastructure on a regular basis to ensure that it is in good working order. If anything changes, CloudFormation receives a detailed response.
        Terraform, on the other hand, stores the state of the infrastructure on the provisioning machine, which can be a virtual machine or a remote computer. Terraform defines the resources it maintains using the state as a map, which is saved as a JSON file.
        To summarise, CloudFormation manages Cloudformation’s state by default, preventing conflicting changes. Terraform saves the state to a local disc, making state synchronisation easier. Terraform states can also be saved in storage services such as S3, which is a recommended additional state management strategy. This must be defined on the backend to facilitate and secure management.
    Cost:
        The best part is that both of these programmes are completely free. Both of these technologies have sizable online communities that provide a wealth of information and examples. Cloudformation is completely free. Customers only need to pay for the AWS service provided by CloudFormation. Terraform is an open-source application that can be used for free. Terraform, on the other hand, has a paid enterprise version that includes additional collaboration and governance features.
    Integration of Multiple Clouds:
        Terraform is the way to go if you want to provide services across multiple cloud platforms. While Terraform can be used with AWS, GCP, Azure, and other cloud providers, CloudFormation is only available on AWS. Cloudformation is not for you if you have multiple cloud installations. If you use AWS resources such as EC2, S3, and so on, you should use Cloudformation.

=== Question 37: Differentiate between Terraform and Ansible.
Answer: Ansible is a deceptively simple IT automation tool. Configuration management, application deployment, cloud provisioning, ad-hoc job execution, network automation, and multi-node orchestration are all handled by this software. Ansible simplifies complex changes such as zero-downtime rolling updates with load balancers. The following table compares and contrasts Ansible and Terraform:
[options="header"]
|===
| Feature | Terraform | Ansible

| Description
| Terraform is a tool for provisioning.
| Ansible is a tool for managing configurations.

| Methodology
| It uses a declarative Infrastructure as Code methodology.
| It takes a procedural method.

| Ideal Use Case
| It’s ideal for orchestrating cloud services and building cloud infrastructure from the ground up.
| It is mostly used to configure servers with the appropriate software and to update resources that have previously been configured.

| Bare Metal Provisioning
| By default, Terraform does not allow bare metal provisioning.
| The provisioning of bare metal servers is supported by Ansible.

| Packing and Templating
| In terms of packing and templating, it does not provide better support.
| It includes complete packaging and templating support.

| State Management
| It is strongly influenced by lifecycle or state management.
| It doesn’t have any kind of lifecycle management. It does not store the state.
|===

=== Question 38: What are the most useful Terraform commands ?

Answer: Here are some useful Terraform Commands

    fmt
    init
    validate
    plan
    apply
    destroy
    output
    show
    state
    version

===  Question 39: Are callbacks possible with Terraform on Azure ?

Answer: Yes. This is possible with Azure Event Hubs.

=== Question 40: What is Terraform Directory?

Answer: Terraform Directory, which Terraform uses to manage cached provider plugins and modules, as well as to record which workspace is currently active and the last known backend configuration in case state needs to be migrated on the next run.

=== Question 41: Is history the same as it is on the web while using TFS API to provide resources ?

Answer: Yes, the narration is similar to that found on the web because UI uses API as its foundation. Everything on the UI is available via other methods and the API.

=== Question 42: What is a Private Module Registry?

Answer: Using the private module registry, Terraform Cloud users can create and confidentially share infrastructure modules within an organisation. The private module registry in Terraform Enterprise allows you to share modules within or across organisations.

=== Question 43: Does Terraform support multi-provider deployments?

Answer: Terraform is a powerful tool in multi-provider deployments because it is not tied to a specific infrastructure or cloud provider. You can manage all resources with the same set of configuration files, sharing variables and defining dependencies across providers.


=== Question 44: How is duplicate resource error ignored during terraform apply ?

Answer: You can:

    To stop managing those resources, remove them from your Terraform code.
    Remove the resources from the API (cloud provider) and recreate them using Terraform.
    Terraform those resources and remove the terraform code that is attempting to recreate them.
    Use terraform apply —target=xxx to apply only the resources you require.

=== Question 45: What are Provisioners in Terraform?

Answer: Provisioners are used to execute scripts on a local or remote machine as part of resource creation or destruction. Provisioners can be used to bootstrap a resource, cleanup before destroy, run configuration management, etc.

=== Question 46: What are some of the built-in provisioners available in Terraform?

Answer: Some of the built-in provisioners available in Terraform are:

. abspath.
. dirname.
. pathexpand.
. basename.
. file.
. fileexists.
. fileset.
. filebase64.

=== Question 47: Tell us about some notable Terraform applications.

Answer: The applications of Terraform are pretty broad due to its facility of extending its abilities for resource manipulation. Some of the unique applications are:

 -   Software demos development
  -  Resource schedulers
 -   Multi-cloud deployment
 -   Disposable environment creations
 -   Multi-tier applications development
  -  Self-service clusters
 -   Setup of Heroku App

=== Question 48: What are the components of Terraform architecture?

Answer: The Terraform architecture includes the following features:

    Sub-graphs
    Expression Evaluation
    Vertex Evaluation
    Graph Walk
    Graph Builder
    State Manager
    Configuration Loader
    CLI (Command Line interface)
    Backend

=== Question 49: Define Resource Graph in Terraform.

Answer: A resource graph is a graphical representation of the available resources. It enables the modification and creation of independent resources at the same time. Terraform creates a plan for the graph’s configuration in order to generate plans and refresh the state. It efficiently and effectively creates structure to help us understand the disadvantages.
Question 50: Can you provide a few examples where we can use for Sentinel policies?

Answer: Sentinels are an effective way to implement a wide range of policies in Terraform. Here are a couple of examples:

  -  Enforce explicit resource ownership.
   - Limit the roles that the cloud provider can play.
  -  Examine the audit trail for Terraform Cloud operations.
  -  Only certain resources, providers, or data sources may be prohibited.
  -  Make resource tagging mandatory.
  -  In the Private Module Registry, you can limit how modules are used.

=== Question 51: What are the various levels of Sentinel enforcement?

Answer: Sentinel has three levels of enforcement: advisory, soft mandatory, and hard mandatory.

. Advisory – Logged in but permitted to pass. When a user initiates a plan that violates the policy, an advisory is issued.
. Soft Mandatory – Unless an override is specified, the policy must be followed. Overrides are only available to administrators.
. Hard Mandatory – The policy must be implemented regardless. Unless and until this policy is removed, it cannot be overridden. Terraform’s default enforcement level is this.

=== Question 52: How to Store Sensitive Data in Terraform?

Answer: To communicate with your cloud provider’s API, Terraform requires credentials. However, these credentials are frequently saved in plaintext on your desktop. Every day, GitHub is exposed to thousands of API and cryptographic keys. As a result, your API keys should never be directly stored in Terraform code. To store passwords, TLS certificates, SSH keys, and anything else that shouldn’t be stored in plain text, use encrypted storage.

=== Question 53: What is Terraform Core? Tell us some primary responsibilities of it

Answer: Terraform Core is a binary written in the Go programming language and statically compiled. The compiled binary provides Terraform users with an entry point. The primary responsibilities are as follows:

  -  Infrastructure’s code functionalities include module and configuration file reading and interpolation.
 -   Building a Resource Graph
 -   RPC-based plugin communication
 -   Plan implementation
 -   Resource state management


===  Question 54: How will you upgrade plugins on Terraform?

image::upgradee.png[]

Answer: Terraform providers are distributed separately from the Terraform binary since Terraform v0.10. This allows them to update at different rates while also allowing a larger group of people to collaborate on the providers. This is mostly positive, but it adds a new step for upgrading providers.
upgrade plugins

=== Question 55: How will you control and handle rollbacks when something goes wrong?

Answer: We will recommit the previous version of the code to my VCS as the new and current version. A terraform run will be triggered, which will be in charge of running the old code. Remember that terraform is more declarative. Check that the old code contains everything that was specified in the code for rollback.

Ensure that it is not destroyed when the old code is run due to a lack of these. If the state file becomes corrupted as a result of a recent Terraform run, I will use Terraform Enterprise’s State Rollback feature to roll back to the most recent good state. Because every state change is versioned, this could be done.

=== Question 56: How can you define dependencies in Terraform?

Answer: You can use depends_on to declare the dependency explicitly. You can also specify multiple resources in the depends on argument, and Terraform will create the target resource after all of them have been created.

=== Question 57: What is the external data block in Terraform?

Answer: The external data source allows an external programme to act as a data source by exposing arbitrary data for use elsewhere in the Terraform configuration by implementing a specific protocol (defined below).

=== Question 58: What happens when multiple engineers start deploying infrastructure using the same state file?

Answer: Terraform has a critical feature known as “state locking.” This feature ensures that no changes to the state file are made during a run, preventing the state file from becoming corrupt. It is important to note that the state locking feature is not supported by all Terraform Backends. If this feature is required, you should select the appropriate backend.

Read: Terraform Variables – Terraform Variable Types

=== Question 59: Which value of the TF_LOG variable provides the MOST verbose logging?

Answer: TRACE is the most verbose option, and it is the default if TF_LOG is not set to a log level name. When logging is enabled, you can set TF_LOG_PATH to force the log to always be appended to a specific file.

=== Question 60: Which command can be used to preview the terraform execution plan?

Answer: The terraform plan command generates an execution plan, which allows you to preview the changes that Terraform intends to make to your infrastructure. When Terraform generates a plan by default, it:

  -  Reads the current state of any existing remote objects to ensure the Terraform state is current.
  -  The current configuration is compared to the previous state, and any differences are noted.
  -  Proposes a set of change actions that, if executed, should cause the remote objects to match the configuration.

===  Question 61: Which command can be used to reconcile the Terraform state with the actual real-world infrastructure?

Answer: Terraform aids in the detection and management of drift. The state file stores information about the real-world state of Terraform-managed infrastructure. The command terraform refresh refreshes this state file, reconciling what Terraform believes is running and its configuration with what is actually running and configured.


===  Question 62: What is the benefit of Terraform State? What is the benefit of using modules in Terraform?

Answer: Terraform state is primarily used to store bindings between remote system items and resource instances specified in your configuration. When Terraform generates a remote object in response to a configuration change, it saves the remote object’s identification to a specific resource instance and may update or remove that object in response to future configuration changes.

We can save time and avoid costly errors by reusing configurations created by you, other members of your team, or other Terraform experts who have published modules for you to use.

=== Question 63: What is Terraform D?

Answer: Terraform D is a plugin used on most in-service systems and Windows. Terraform init by default searches next directories for plugins.

=== Question 64: How will you upgrade plugins on Terraform?

Answer: Run ‘terraform init’ with ‘-upgrade’ option. This command rechecks the releases.hashicorp.com to find new acceptable provider versions. It also downloads available provider versions. “.terraform/plugins/<OS>_<ARCH>” is the automatic downloads directory.

=== Question 65: What are some of the latest Terraform Azure Provider factors?

Answer: The latest versions involve new data resources and Azurem_batch_certificate, which helps in managing the certificate. This resource is used for controlling the prefix in networking. There is fixing of bugs, and azurerm_app_service has also been enhanced.

=== Question 66: What is Terraform Core? Tell us some primary responsibilities of it.

Answer: Terraform Core is a binary written statically compiled by using the Go programming language. The compiled binary offers an entry point for the users of Terraform. The primary responsibilities include:

  -  Reading and interpolation of modules and configuration files by Infrastructure as code functionalities
 -   Resource Graph Construction
  -  Plugin communication through RPC
  -  Plan execution
  -  Management of resource state

===  Question 67: What is Terragrunt, and what are its uses?

Answer: Terragrunt is a thin wrapper that provides extra tools to keep configurations DRY, manage remote state and work with multiple Terraform modules. It is used for:

  -  Working with multiple AWS accounts
  -  Executing Terraform commands on multiple modules
  -  Keeping our CLI flags DRY
  -  Keeping our remote state configuration DRY
  -  Keeping our Terraform code DRY

===  Question 68: What is a “tainted resource”?

Answer: A tainted resource must be deleted and regenerated when the following apply command is sent. The state files are changed when a resource is identified as contaminated, but nothing changes the infrastructure. The terraform plan reveals that assistance will be destroyed and rebuilt. When the next application occurs, the modifications are applied.

=== Question 69: In Terraform, define the Resource Graph.

Answer: A resource graph is used to depict the resources. It allows you to simultaneously alter and produce various resources. Terraform creates a plan to update the state of the graph’s configuration. It quickly establishes a system to aid us in recognizing drawbacks.

===  Question 70: What are the different degrees of Sentinel policing?

Answer: There are three degrees of enforcement in Sentinel: advisory, soft mandatory, and hard obligatory.

   - Advisory – You’ve been logged in, but you’re free to leave. When a user initiates a plan that violates the rules, an advisory is sent.
  -  Soft Mandatory – Unless an override is stated, the policy must pass. Overrides are only available to administrators.
  -  Hard Mandatory – The policy must pass regardless of the circumstances. Unless it is abolished, this policy cannot be overridden. In Terraform, this is the default enforcement level.

Some other important terraform commands for technical interview questions on terraform

  -  terraform init: In order to prepare the working directory for use with Terraform, the terraform init command performs Backend Initialization, Child Module Installation, and Plugin Installation.
  -  terraform apply: The terraform apply command executes the actions proposed in a Terraform plan
  -  terraform apply –auto-approve: Skips interactive approval of plan before applying.
  -  terraform destroy: The terraform destroy command is a convenient way to destroy all remote objects managed by a particular Terraform configuration.
 -   terraform fmt: The terraform fmt command is used to rewrite Terraform configuration files to a canonical format and style
 -   terraform show: The terraform show command is used to provide human-readable output from a state or plan file.


== Frequently Asked Questions
=== What is the difference between Terraform's declarative and imperative approaches?

Terraform follows a declarative approach, where you define the desired state of the infrastructure, and Terraform takes care of the provisioning and management details. In contrast, imperative approaches involve specifying the step-by-step instructions to create and manage resources, which can be more error-prone and harder to maintain.

=== How does Terraform differ from other infrastructure-as-code tools?

Terraform differentiates itself by being cloud-agnostic and supporting multiple cloud providers. It uses a declarative approach, where you define the desired state of the infrastructure, and Terraform handles the provisioning and management of resources to reach that state. Unlike some imperative tools, Terraform is idempotent and can plan and execute changes without modifying unrelated resources.

=== What are Terraform workspaces, and when are they useful?

Terraform workspaces allow you to manage multiple instances of the same infrastructure in separate environments (e.g., development, staging, production). Workspaces keep state and configurations isolated, enabling you to switch between environments easily. They are particularly useful when working with shared infrastructure code across different stages of the software development lifecycle.